
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module StoreArgumentsProps</title>
<meta name="description" content="Documentation of Coq module StoreArgumentsProps" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module StoreArgumentsProps</h1>
<div class="coq">
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">CoqlibC</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Maps</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Integers</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ValuesC</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">MemoryC</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Globalenvs</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Events</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Op</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">LocationsC</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Conventions</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">SimMemInj</span>.<br/>
<span class="kwd">Require</span> <span class="id">Stacklayout</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Asm</span> <span class="id">Mach</span> <span class="id">mktac</span> <span class="id">MemdataC</span> <span class="id">AsmregsC</span> <span class="id">StoreArguments</span>.<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">agree</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">rs0</span> <span class="id">rs1</span>: <span class="id">Mach.regset</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mr</span>, <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">rs0</span> <span class="id">mr</span>) (<span class="id">rs1</span> <span class="id">mr</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">typesize_chunk</span>: <span class="kwd">forall</span> <span class="id">ty</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">size_chunk</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) = 4 * <span class="id">ty</span>.(<span class="id">typesize</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6379')">Proof.</div>
<div class="proofscript" id="proof6379">
 <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="id">ss</span>. Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">STOREARGUMENTS_PROPERTY</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">extcall_arguments_same</span> (<span class="id">rs0</span> <span class="id">rs1</span>: <span class="id">Mach.regset</span>) <span class="id">sp</span> <span class="id">m</span> <span class="id">sg</span> <span class="id">args</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGS</span>: <span class="id">extcall_arguments</span> <span class="id">rs0</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">sg</span> <span class="id">args</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SAME</span>: <span class="kwd">forall</span> <span class="id">r</span> (<span class="id">IN</span>: <span class="id">In</span> (<span class="id">R</span> <span class="id">r</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>))), <span class="id">rs0</span> <span class="id">r</span> = <span class="id">rs1</span> <span class="id">r</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">extcall_arguments</span> <span class="id">rs1</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">sg</span> <span class="id">args</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6380')">Proof.</div>
<div class="proofscript" id="proof6380">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">ARGS</span> <span class="id">SAME</span>. <span class="tactic">unfold</span> <span class="id">extcall_arguments</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">args</span> <span class="id">ARGS</span> <span class="id">SAME</span>. <span class="tactic">generalize</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>). <span class="tactic">induction</span> <span class="id">l</span>; <span class="id">ss</span>; <span class="id">i</span>; <span class="id">inv</span> <span class="id">ARGS</span>; <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span> 1. <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">eauto</span>; <span class="tactic">try</span> <span class="id">econs</span>; <span class="tactic">eauto</span>. <span class="id">erewrite</span> <span class="id">SAME</span>; <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>;  <span class="id">econs</span>; <span class="tactic">eauto</span>; <span class="tactic">try</span> <span class="id">erewrite</span> <span class="id">SAME</span>; <span class="tactic">eauto</span>; (<span class="tactic">try</span> <span class="tactic">by</span> <span class="id">econs</span>; <span class="tactic">eauto</span>); <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">IHl</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">SAME</span>. <span class="tactic">eapply</span> <span class="id">in_app</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">extcall_arg_in_reg</span> (<span class="id">rs</span>: <span class="id">regset</span>) (<span class="id">l</span>: <span class="id">rpair</span> <span class="id">loc</span>) (<span class="id">v</span>: <span class="id">val</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> (<span class="id">EQ</span>: <span class="id">l</span> = <span class="id">One</span> (<span class="id">R</span> <span class="id">r</span>)), <span class="id">v</span> = <span class="id">rs</span> <span class="id">r</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">extcall_arg_in_stack</span> (<span class="id">m</span>: <span class="id">ZMap.t</span> <span class="id">memval</span>) (<span class="id">lo</span>: <span class="id">Z</span>) (<span class="id">l</span>: <span class="id">rpair</span> <span class="id">loc</span>) (<span class="id">v</span>: <span class="id">val</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span> (<span class="id">EQ</span>: <span class="id">l</span> = <span class="id">One</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">decode_val</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) (<span class="id">Mem.getN</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)) (<span class="id">lo</span> + 4 * <span class="id">ofs</span>) <span class="id">m</span>) = <span class="id">v</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">extcall_arguments_extcall_arg_in_reg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rs</span> <span class="id">m</span> <span class="id">blk</span> <span class="id">sg</span> <span class="id">vs</span> <span class="id">lo</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SZ</span>: 0 &lt;= <span class="id">lo</span> /\ <span class="id">lo</span> + 4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">Ptrofs.max_unsigned</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGS</span>: <span class="id">list_forall2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">extcall_arg_pair</span> <span class="id">rs</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">blk</span> (<span class="id">Ptrofs.repr</span> <span class="id">lo</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">loc_arguments</span> <span class="id">sg</span>) <span class="id">vs</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> (<span class="id">extcall_arg_in_reg</span> <span class="id">rs</span>) (<span class="id">loc_arguments</span> <span class="id">sg</span>) <span class="id">vs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6381')">Proof.</div>
<div class="proofscript" id="proof6381">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">loc_arguments_acceptable</span> <span class="id">sg</span>). <span class="tactic">generalize</span> (@<span class="id">loc_arguments_ofs_bounded</span> <span class="id">sg</span> <span class="id">lo</span> <span class="id">SZ</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">vs</span> <span class="id">ARGS</span>. <span class="tactic">induction</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>); <span class="id">ss</span>; <span class="id">i</span>; <span class="id">inv</span> <span class="id">ARGS</span>; <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>. <span class="id">clarify</span>. <span class="id">inv</span> <span class="id">H3</span>. <span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">IHl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">extcall_arguments_extcall_arg_in_stack</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rs</span> <span class="id">m</span> <span class="id">blk</span> <span class="id">sg</span> <span class="id">vs</span> <span class="id">lo</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SZ</span>: 0 &lt;= <span class="id">lo</span> /\ <span class="id">lo</span> + 4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">Ptrofs.max_unsigned</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGS</span>: <span class="id">list_forall2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">extcall_arg_pair</span> <span class="id">rs</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">blk</span> (<span class="id">Ptrofs.repr</span> <span class="id">lo</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">loc_arguments</span> <span class="id">sg</span>) <span class="id">vs</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">extcall_arg_in_stack</span> (<span class="id">m</span>.(<span class="id">Mem.mem_contents</span>) !! <span class="id">blk</span>) <span class="id">lo</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">loc_arguments</span> <span class="id">sg</span>) <span class="id">vs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6382')">Proof.</div>
<div class="proofscript" id="proof6382">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">loc_arguments_acceptable</span> <span class="id">sg</span>). <span class="tactic">generalize</span> (@<span class="id">loc_arguments_ofs_bounded</span> <span class="id">sg</span> <span class="id">lo</span> <span class="id">SZ</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">vs</span> <span class="id">ARGS</span>. <span class="tactic">induction</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>); <span class="id">ss</span>; <span class="id">i</span>; <span class="id">inv</span> <span class="id">ARGS</span>; <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>. <span class="id">clarify</span>. <span class="id">inv</span> <span class="id">H3</span>. <span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">unfold</span> <span class="id">load_stack</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">Mem.load</span>. <span class="tactic">unfold</span> <span class="id">Mem.load</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.Ptrofs_add_repr</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">IHl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">extcall_arg_in_stack_in_reg_extcall_argument</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span> <span class="id">blk</span> <span class="id">m_blk</span> <span class="id">rs</span> <span class="id">vs</span> <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACK</span>: <span class="id">list_forall2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">extcall_arg_in_stack</span> <span class="id">m_blk</span> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">loc_arguments</span> <span class="id">sg</span>) <span class="id">vs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">REGS</span>: <span class="id">list_forall2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">extcall_arg_in_reg</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">loc_arguments</span> <span class="id">sg</span>) <span class="id">vs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MBLK</span>: <span class="id">m</span>.(<span class="id">Mem.mem_contents</span>) !! <span class="id">blk</span> = <span class="id">m_blk</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PERM</span>: <span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">blk</span> 0 (4 * <span class="id">size_arguments</span> <span class="id">sg</span>) <span class="id">Cur</span> <span class="id">Freeable</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SZ</span>: 4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">Ptrofs.max_unsigned</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">extcall_arg_pair</span> <span class="id">rs</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">blk</span> <span class="id">Ptrofs.zero</span>)) (<span class="id">loc_arguments</span> <span class="id">sg</span>) <span class="id">vs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6383')">Proof.</div>
<div class="proofscript" id="proof6383">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">loc_arguments_acceptable</span> <span class="id">sg</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SZ0</span>: 0 &lt;= 0 /\ 0 + 4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">Ptrofs.max_unsigned</span>) <span class="tactic">by</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (@<span class="id">loc_arguments_ofs_bounded</span> <span class="id">sg</span> 0 <span class="id">SZ0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">RANGE</span>: <span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span> (<span class="id">In</span>: <span class="id">In</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>))),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">blk</span> (4 * <span class="id">ofs</span>) (4 * (<span class="id">ofs</span> + <span class="id">typesize</span> <span class="id">ty</span>)) <span class="id">Cur</span> <span class="id">Freeable</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">i</span>. <span class="id">hexploit</span> <span class="id">loc_arguments_bounded</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">PERM</span>. <span class="tactic">split</span>; <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">loc_arguments_acceptable</span>; <span class="tactic">eauto</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">instantiate</span> (1:= <span class="id">One</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>)). <span class="id">i</span>. <span class="id">inv</span> <span class="id">H1</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">instantiate</span> (1:= <span class="id">sg</span>). <span class="tactic">generalize</span> (<span class="id">loc_arguments_one</span> <span class="id">sg</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">In</span>. <span class="tactic">clear</span>. <span class="tactic">induction</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>); <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="id">dup</span> <span class="id">H</span>. <span class="id">specialize</span> (<span class="id">H</span> <span class="id">_</span> (<span class="id">or_introl</span> <span class="id">eq_refl</span>)). <span class="tactic">unfold</span> <span class="id">is_one</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>. <span class="id">ss</span>. <span class="id">des</span>; <span class="id">clarify</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">loc_arguments_one</span> <span class="id">sg</span>). <span class="id">revert</span> <span class="id">vs</span> <span class="id">STACK</span> <span class="id">REGS</span> <span class="id">RANGE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>); <span class="id">ss</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">STACK</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">STACK</span>. <span class="id">inv</span> <span class="id">REGS</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">a</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exfalso</span>. <span class="id">hexploit</span> <span class="id">H</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">econs</span>. <span class="id">exploit</span> <span class="id">H7</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">clarify</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">sl</span>; <span class="tactic">try</span> (<span class="tactic">by</span> <span class="id">exfalso</span>; <span class="id">exploit</span> <span class="id">H1</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>. <span class="id">exploit</span> <span class="id">H4</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">des</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">load_stack</span>, <span class="id">Mem.loadv</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">Mem.load</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exfalso</span>. <span class="tactic">apply</span> <span class="id">n</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_access</span>. <span class="tactic">split</span>; <span class="id">ii</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.perm_implies</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">RANGE</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">split</span>; <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span> <span class="kwd">in</span> *; <span class="tactic">try</span> (<span class="tactic">by</span> <span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H1</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="id">ss</span>; <span class="tactic">eapply</span> <span class="id">Z.mul_divide_mono_l</span> <span class="kwd">with</span> (<span class="id">p</span> := 4) <span class="kwd">in</span> <span class="id">H5</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">IHl</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">RANGE</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">in_or_app</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">store_arguments_unchanged_on</span> <span class="id">m0</span> <span class="id">m1</span> <span class="id">rs</span> <span class="id">args</span> <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STORE</span>: <span class="id">store_arguments</span> <span class="id">m0</span> <span class="id">rs</span> <span class="id">args</span> <span class="id">sg</span> <span class="id">m1</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.unchanged_on</span> <span class="id">top2</span> <span class="id">m0</span> <span class="id">m1</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6384')">Proof.</div>
<div class="proofscript" id="proof6384">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STORE</span>. <span class="id">dup</span> <span class="id">ALC</span>. <span class="tactic">eapply</span> <span class="id">Mem.alloc_unchanged_on</span> <span class="kwd">in</span> <span class="id">ALC0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_implies</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">i</span>. <span class="id">ss</span>. <span class="id">des_ifs</span>. <span class="id">exfalso</span>. <span class="tactic">eapply</span> <span class="id">Mem.fresh_block_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">STOREARGUMENTS_PROPERTY</span>.<br/>
<br/>
<br/>
<br/>
<span class="kwd">Module</span> <span class="id">_FillArgsParallel</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">unsigned_add</span> <span class="id">ofs</span> <span class="id">delta</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RANGE</span>: <span class="id">delta</span> &gt;= 0 /\ 0 &lt;= <span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">delta</span> &lt;= <span class="id">Ptrofs.max_unsigned</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Ptrofs.unsigned</span> (<span class="id">Ptrofs.add</span> <span class="id">ofs</span> (<span class="id">Ptrofs.repr</span> <span class="id">delta</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">delta</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6385')">Proof.</div>
<div class="proofscript" id="proof6385">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.add_unsigned</span>. <span class="tactic">replace</span> (<span class="id">Ptrofs.unsigned</span> (<span class="id">Ptrofs.repr</span> <span class="id">delta</span>)) <span class="kwd">with</span> <span class="id">delta</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Ptrofs.unsigned_repr</span>; <span class="tactic">eauto</span>. <span class="id">des</span>. <span class="id">splits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">Ptrofs.unsigned_repr</span>; <span class="tactic">eauto</span>. <span class="id">des</span>. <span class="id">splits</span>; [<span class="id">xomega</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> &gt;= 0); [|<span class="id">xomega</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">Ptrofs.unsigned_range</span> <span class="id">ofs</span>). <span class="id">des</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">copy_memval</span> (<span class="id">v</span>: <span class="id">val</span>) (<span class="id">mv</span>: <span class="id">memval</span>) : <span class="id">memval</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">v</span>, <span class="id">mv</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Vundef</span>, <span class="id">_</span> =&gt; <span class="id">Undef</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">Fragment</span> <span class="id">_</span> <span class="id">q</span> <span class="id">n</span> =&gt; <span class="id">Fragment</span> <span class="id">v</span> <span class="id">q</span> <span class="id">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">mv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">copy_list_memval</span> (<span class="id">v</span>: <span class="id">val</span>): <span class="id">list</span> <span class="id">memval</span> -&gt; <span class="id">list</span> <span class="id">memval</span> := <span class="id">map</span> (<span class="id">copy_memval</span> <span class="id">v</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">copy_list_memval_decode_undef</span> <span class="id">vl</span> <span class="id">vl</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">COPY</span>: <span class="id">copy_list_memval</span> <span class="id">Vundef</span> <span class="id">vl</span> = <span class="id">vl</span>'):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vl</span>' = <span class="id">list_repeat</span> (<span class="id">List.length</span> <span class="id">vl</span>) <span class="id">Undef</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6386')">Proof.</div>
<div class="proofscript" id="proof6386">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">vl</span>' <span class="id">COPY</span>. <span class="tactic">induction</span> <span class="id">vl</span>; <span class="id">ss</span>; <span class="id">i</span>; <span class="id">clarify</span>. <span class="tactic">f_equal</span>. <span class="tactic">eapply</span> <span class="id">IHvl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">copy_list_memval_decode_pointer</span> <span class="id">j</span> <span class="id">vl</span> <span class="id">vl</span>' <span class="id">chunk</span> <span class="id">v</span> <span class="id">blk</span> <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJ</span>: <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> (<span class="id">decode_val</span> <span class="id">chunk</span> <span class="id">vl</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">COPY</span>: <span class="id">copy_list_memval</span> <span class="id">v</span> <span class="id">vl</span> = <span class="id">vl</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VALUE</span>: <span class="id">v</span> = <span class="id">Vptr</span> <span class="id">blk</span> <span class="id">ofs</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">decode_val</span> <span class="id">chunk</span> <span class="id">vl</span>' = <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6387')">Proof.</div>
<div class="proofscript" id="proof6387">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">H</span>: <span class="id">DUMMY_PROP</span>) <span class="tactic">by</span> <span class="id">ss</span>. <span class="id">clarify</span>. <span class="id">inv</span> <span class="id">INJ</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">decode_val</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">destruct</span> <span class="id">vl</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">des_ifs_safe</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">m</span>, <span class="id">chunk</span>; <span class="id">ss</span>; <span class="id">des_ifs_safe</span>; <span class="id">cycle</span> 10.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">repeat</span> ((<span class="tactic">repeat</span> <span class="id">apply_all_once</span> <span class="id">andb_prop</span>; <span class="id">des</span>); <span class="id">des_sumbool</span>; <span class="id">clarify</span>; <span class="id">des_ifs_safe</span>; <span class="id">ss</span>; <span class="id">des</span>; <span class="id">ss</span>; <span class="id">clarify</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">decode_val</span>; <span class="id">des_ifs</span>. <span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">proj_sumbool</span>, <span class="id">andb</span>. <span class="id">des_ifs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">v</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">repeat</span> ((<span class="tactic">repeat</span> <span class="id">apply_all_once</span> <span class="id">andb_prop</span>; <span class="id">des</span>); <span class="id">des_sumbool</span>; <span class="id">clarify</span>; <span class="id">des_ifs_safe</span>; <span class="id">ss</span>; <span class="id">des</span>; <span class="id">ss</span>; <span class="id">clarify</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">decode_val</span>; <span class="id">des_ifs</span>. <span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">proj_sumbool</span>, <span class="id">andb</span>. <span class="id">des_ifs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">all</span>: <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">copy_list_memval_decode</span> <span class="id">j</span> <span class="id">vl</span> <span class="id">vl</span>' <span class="id">chunk</span> <span class="id">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJ</span>: <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> (<span class="id">decode_val</span> <span class="id">chunk</span> <span class="id">vl</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">COPY</span>: <span class="id">copy_list_memval</span> <span class="id">v</span> <span class="id">vl</span> = <span class="id">vl</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LENGTH</span>: <span class="id">Nat.lt</span> 0 (<span class="id">length</span> <span class="id">vl</span>)):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">decode_val</span> <span class="id">chunk</span> <span class="id">vl</span>' = <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6388')">Proof.</div>
<div class="proofscript" id="proof6388">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">INJ</span>; <span class="tactic">try</span> (<span class="tactic">by</span> <span class="tactic">rewrite</span> <span class="id">H1</span>; <span class="tactic">f_equal</span>; <span class="tactic">apply</span> <span class="id">eq_Forall2_eq</span>; <span class="tactic">eapply</span> <span class="id">Forall2_in_map</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="tactic">rewrite</span> &lt;- <span class="id">H1</span>; <span class="tactic">destruct</span> <span class="id">a</span>; <span class="id">ss</span>; <span class="tactic">f_equal</span>; <span class="tactic">symmetry</span>; <span class="tactic">eapply</span> <span class="id">decode_fragment_all</span>; <span class="tactic">eauto</span>; <span class="id">ii</span>; <span class="id">clarify</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">copy_list_memval_decode_pointer</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">copy_list_memval_decode_undef</span>. <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">vl</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">LENGTH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">decode_val</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">copy_list_memval_inject</span> <span class="id">j</span> <span class="id">vl</span> <span class="id">vl</span>' <span class="id">chunk</span> <span class="id">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJ</span>: <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> (<span class="id">decode_val</span> <span class="id">chunk</span> <span class="id">vl</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">COPY</span>: <span class="id">copy_list_memval</span> <span class="id">v</span> <span class="id">vl</span> = <span class="id">vl</span>'):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> (<span class="id">memval_inject</span> <span class="id">j</span>) <span class="id">vl</span>' <span class="id">vl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6389')">Proof.</div>
<div class="proofscript" id="proof6389">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">clarify</span>. <span class="tactic">destruct</span> <span class="id">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exploit</span> <span class="id">copy_list_memval_decode_undef</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">eapply</span> <span class="id">repeat_Undef_inject_any</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">all</span>: <span class="tactic">eapply</span> <span class="id">Forall2_in_map</span>; <span class="id">i</span>; <span class="tactic">destruct</span> <span class="id">a</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="id">econs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">decode_fragment_all</span>; <span class="tactic">eauto</span>; <span class="id">ii</span>; <span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> *; <span class="id">inv</span> <span class="id">INJ</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">fill_arg_src_reg</span> (<span class="id">rs</span>: <span class="id">regset</span>) (<span class="id">arg</span>: <span class="id">val</span>) (<span class="id">loc</span>: <span class="id">rpair</span> <span class="id">loc</span>): <span class="id">regset</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">loc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">One</span> (<span class="id">R</span> <span class="id">r</span>) =&gt; <span class="id">rs</span>#<span class="id">r</span> &lt;- <span class="id">arg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">rs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Fixpoint</span> <span class="id">fill_args_src_reg</span> (<span class="id">args</span>: <span class="id">list</span> <span class="id">val</span>) (<span class="id">locs</span>: <span class="id">list</span> (<span class="id">rpair</span> <span class="id">loc</span>)): <span class="id">regset</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">args</span>, <span class="id">locs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">vhd</span>::<span class="id">vtl</span>, <span class="id">lhd</span>::<span class="id">ltl</span> =&gt; <span class="id">fill_arg_src_reg</span> (<span class="id">fill_args_src_reg</span> <span class="id">vtl</span> <span class="id">ltl</span>) <span class="id">vhd</span> <span class="id">lhd</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id">Vundef</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fill_args_src_reg_args</span> <span class="id">args</span> <span class="id">locs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOREPEAT</span>: <span class="id">Loc.norepet</span> (<span class="id">regs_of_rpairs</span> <span class="id">locs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ONES</span>: <span class="kwd">forall</span> <span class="id">l</span> (<span class="id">IN</span>: <span class="id">In</span> <span class="id">l</span> <span class="id">locs</span>), <span class="id">is_one</span> <span class="id">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LENGTH</span>: <span class="id">length</span> <span class="id">args</span> = <span class="id">length</span> <span class="id">locs</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> (<span class="id">extcall_arg_in_reg</span> (<span class="id">fill_args_src_reg</span> <span class="id">args</span> <span class="id">locs</span>)) <span class="id">locs</span> <span class="id">args</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6390')">Proof.</div>
<div class="proofscript" id="proof6390">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">NOREPEAT</span> <span class="id">args</span> <span class="id">LENGTH</span>. <span class="tactic">induction</span> <span class="id">locs</span>; <span class="id">ss</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">LENGTH</span>. <span class="tactic">destruct</span> <span class="id">a</span>; <span class="id">inv</span> <span class="id">NOREPEAT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">fill_arg_src_reg</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id">ii</span>. <span class="id">inv</span> <span class="id">EQ</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gss</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="tactic">eapply</span> <span class="id">list_forall2_lift</span>; [|<span class="tactic">eauto</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="id">clarify</span>. <span class="tactic">unfold</span> <span class="id">Regmap.set</span>. <span class="id">des_ifs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exfalso</span>. <span class="tactic">eapply</span> <span class="id">loc_notin_not_in</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">in_one_in_rpair</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">econs</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="id">inv</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">exfalso</span>. <span class="id">exploit</span> <span class="id">ONES</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fill_args_src_reg_agree</span> <span class="id">j</span> <span class="id">args</span> <span class="id">args_tgt</span> <span class="id">locs</span> <span class="id">rs_tgt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJECT</span>: <span class="id">Val.inject_list</span> <span class="id">j</span> <span class="id">args</span> <span class="id">args_tgt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LENGTH</span>: <span class="id">length</span> <span class="id">args</span> = <span class="id">length</span> <span class="id">locs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGS</span>: <span class="id">list_forall2</span> (<span class="id">extcall_arg_in_reg</span> <span class="id">rs_tgt</span>) <span class="id">locs</span> <span class="id">args_tgt</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">agree</span> <span class="id">j</span> (<span class="id">fill_args_src_reg</span> <span class="id">args</span> <span class="id">locs</span>) <span class="id">rs_tgt</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6391')">Proof.</div>
<div class="proofscript" id="proof6391">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">args</span>. <span class="id">revert</span> <span class="id">rs_tgt</span> <span class="id">args_tgt</span> <span class="id">ARGS</span>. <span class="tactic">induction</span> <span class="id">locs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">LENGTH</span>. <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">INJECT</span>. <span class="id">inv</span> <span class="id">LENGTH</span>. <span class="id">inv</span> <span class="id">ARGS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fill_arg_src_reg</span>. <span class="id">des_ifs</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Regmap.set</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">H5</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">fill_arg_src_blk</span> (<span class="id">m_tgt</span> <span class="id">m</span>: <span class="id">ZMap.t</span> <span class="id">memval</span>) (<span class="id">lo_tgt</span> <span class="id">lo</span>: <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">arg</span>: <span class="id">val</span>) (<span class="id">loc</span>: <span class="id">rpair</span> <span class="id">loc</span>): <span class="id">ZMap.t</span> <span class="id">memval</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">loc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">One</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.setN</span> (<span class="id">copy_list_memval</span> <span class="id">arg</span> (<span class="id">Mem.getN</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)) (<span class="id">lo_tgt</span> + 4 * <span class="id">ofs</span>) <span class="id">m_tgt</span>)) (<span class="id">lo</span> + 4 * <span class="id">ofs</span>) <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Fixpoint</span> <span class="id">fill_args_src_blk</span> (<span class="id">m_tgt</span> <span class="id">m</span>: <span class="id">ZMap.t</span> <span class="id">memval</span>) (<span class="id">lo_tgt</span> <span class="id">lo</span>: <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">args</span>: <span class="id">list</span> <span class="id">val</span>) (<span class="id">locs</span>: <span class="id">list</span> (<span class="id">rpair</span> <span class="id">loc</span>)): <span class="id">ZMap.t</span> <span class="id">memval</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">args</span>, <span class="id">locs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">vhd</span>::<span class="id">vtl</span>, <span class="id">lhd</span>::<span class="id">ltl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fill_arg_src_blk</span> <span class="id">m_tgt</span> (<span class="id">fill_args_src_blk</span> <span class="id">m_tgt</span> <span class="id">m</span> <span class="id">lo_tgt</span> <span class="id">lo</span> <span class="id">vtl</span> <span class="id">ltl</span>) <span class="id">lo_tgt</span> <span class="id">lo</span> <span class="id">vhd</span> <span class="id">lhd</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">only_args_blk</span> (<span class="id">m</span>: <span class="id">ZMap.t</span> <span class="id">memval</span>) (<span class="id">locs</span>: <span class="id">list</span> <span class="id">loc</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">UNDEF</span>: <span class="id">ZMap.get</span> <span class="id">ofs</span> <span class="id">m</span> = <span class="id">Undef</span> &gt;&gt;) \/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">INARGS</span>: <span class="id">exists</span> <span class="id">ofs0</span> <span class="id">ty</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">IN</span>: <span class="id">In</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs0</span> <span class="id">ty</span>) <span class="id">locs</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">RANGE</span>: 4 * <span class="id">ofs0</span> &lt;= <span class="id">ofs</span> &lt; 4 * <span class="id">ofs0</span> + <span class="id">size_chunk</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">LOAD</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">decode_val</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) (<span class="id">Mem.getN</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)) (4 * <span class="id">ofs0</span>) <span class="id">m</span>) = <span class="id">v</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">VDEF</span>: <span class="id">v</span> &lt;&gt; <span class="id">Vundef</span>&gt;&gt;)&gt;&gt;).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">only_args_blk_incr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span> <span class="id">a</span> <span class="id">l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ONLY</span>: <span class="id">only_args_blk</span> <span class="id">m</span> <span class="id">l</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">only_args_blk</span> <span class="id">m</span> (<span class="id">a</span>::<span class="id">l</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6392')">Proof.</div>
<div class="proofscript" id="proof6392">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">specialize</span> (<span class="id">ONLY</span> <span class="id">ofs</span>). <span class="id">des</span>; <span class="tactic">auto</span>. <span class="id">right</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>. <span class="id">ss</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fill_args_src_blk_only_args</span> <span class="id">m_tgt</span> <span class="id">j</span> <span class="id">args_tgt</span> <span class="id">args</span> <span class="id">locs</span> <span class="id">lo_tgt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJECT</span>: <span class="id">Val.inject_list</span> <span class="id">j</span> <span class="id">args</span> <span class="id">args_tgt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOREPEAT</span>: <span class="id">Loc.norepet</span> (<span class="id">regs_of_rpairs</span> <span class="id">locs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LENGTH</span>: <span class="id">length</span> <span class="id">args</span> = <span class="id">length</span> <span class="id">locs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ONES</span>: <span class="kwd">forall</span> <span class="id">l</span> (<span class="id">IN</span>: <span class="id">In</span> <span class="id">l</span> <span class="id">locs</span>), <span class="id">is_one</span> <span class="id">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGS</span>: <span class="id">list_forall2</span> (<span class="id">extcall_arg_in_stack</span> <span class="id">m_tgt</span> <span class="id">lo_tgt</span>) <span class="id">locs</span> <span class="id">args_tgt</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">only_args_blk</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fill_args_src_blk</span> <span class="id">m_tgt</span> (<span class="id">ZMap.init</span> <span class="id">Undef</span>) <span class="id">lo_tgt</span> 0 <span class="id">args</span> <span class="id">locs</span>) (<span class="id">regs_of_rpairs</span> <span class="id">locs</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6393')">Proof.</div>
<div class="proofscript" id="proof6393">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">args</span>. <span class="id">revert</span> <span class="id">m_tgt</span> <span class="id">args_tgt</span> <span class="id">ARGS</span> <span class="id">NOREPEAT</span> <span class="id">ONES</span>. <span class="tactic">induction</span> <span class="id">locs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">LENGTH</span>. <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">ii</span>. <span class="tactic">rewrite</span> <span class="id">ZMap.gi</span>. <span class="id">left</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">INJECT</span>. <span class="id">inv</span> <span class="id">LENGTH</span>. <span class="id">inv</span> <span class="id">ARGS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">loc_norepet_app</span>; <span class="tactic">eauto</span>. } <span class="tactic">intros</span> <span class="id">ONLY</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fill_arg_src_blk</span>. <span class="id">des_ifs</span>; <span class="tactic">try</span> (<span class="tactic">by</span> <span class="tactic">eapply</span> <span class="id">only_args_blk_incr</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ss</span>. <span class="id">ii</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classic</span> (4 * <span class="id">pos</span> &lt;= <span class="id">ofs</span> &lt; 4 * <span class="id">pos</span> + <span class="id">Z.of_nat</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">assert</span> (<span class="id">LEQ</span>: <span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Datatypes.length</span> (<span class="id">copy_list_memval</span> <span class="id">v</span> (<span class="id">Mem.getN</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)) (<span class="id">lo_tgt</span> + 4 * <span class="id">pos</span>) <span class="id">m_tgt</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">copy_list_memval</span>. <span class="tactic">rewrite</span> <span class="id">map_length</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.getN_length</span>. <span class="tactic">auto</span>. } <span class="id">exploit</span> <span class="id">Mem.getN_in</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">LEQ</span> <span class="tactic">at</span> 1. <span class="tactic">rewrite</span> <span class="id">Mem.getN_setN_same</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1:=<span class="id">fill_args_src_blk</span> <span class="id">m_tgt</span> (<span class="id">ZMap.init</span> <span class="id">Undef</span>) <span class="id">lo_tgt</span> 0 <span class="id">args</span> <span class="id">locs</span>). <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">v</span> = <span class="id">Vundef</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">clarify</span>. <span class="tactic">unfold</span> <span class="id">copy_list_memval</span>, <span class="id">copy_memval</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">list_in_map_inv</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="id">des</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="id">left</span>. <span class="id">econs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">right</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">size_chunk_conv</span> <span class="kwd">in</span> *. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">erewrite</span> <span class="id">copy_list_memval_decode</span>; <span class="tactic">try</span> <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">H5</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">rewrite</span> <span class="id">H8</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">LEQ</span> <span class="tactic">at</span> 2. <span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">Mem.getN_setN_same</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">Mem.getN_length</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">size_chunk_nat_pos</span>. <span class="tactic">intros</span> <span class="id">SZ</span>. <span class="id">des</span>. <span class="tactic">rewrite</span> <span class="id">SZ</span>. <span class="tactic">compute</span>. <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">specialize</span> (<span class="id">ONLY</span> <span class="id">ofs</span>). <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">left</span>. <span class="id">erewrite</span> <span class="id">Mem.setN_other</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">copy_list_memval</span>. <span class="id">erewrite</span> <span class="id">map_length</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.getN_length</span>. <span class="id">ii</span>. <span class="id">clarify</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">right</span>. <span class="id">esplits</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>. <span class="id">erewrite</span> <span class="id">Mem.getN_setN_outside</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">copy_list_memval</span>. <span class="id">erewrite</span> <span class="id">map_length</span>. <span class="id">erewrite</span> <span class="id">Mem.getN_length</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> &lt;- <span class="id">size_chunk_conv</span> <span class="kwd">in</span> *. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">typesize_chunk</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty0</span>). <span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">NOREPEAT</span>. <span class="id">exploit</span> <span class="id">Loc.in_notin_diff</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">ss</span>. <span class="id">des</span>; <span class="id">clarify</span>; <span class="id">lia</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ss</span>. <span class="id">exploit</span> <span class="id">ONES</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fill_args_src_blk_inject</span> <span class="id">m_tgt</span> <span class="id">j</span> <span class="id">args_tgt</span> <span class="id">args</span> <span class="id">locs</span> <span class="id">lo_tgt</span> <span class="id">lo</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJECT</span>: <span class="id">Val.inject_list</span> <span class="id">j</span> <span class="id">args</span> <span class="id">args_tgt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LENGTH</span>: <span class="id">length</span> <span class="id">args</span> = <span class="id">length</span> <span class="id">locs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGS</span>: <span class="id">list_forall2</span> (<span class="id">extcall_arg_in_stack</span> <span class="id">m_tgt</span> <span class="id">lo_tgt</span>) <span class="id">locs</span> <span class="id">args_tgt</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span>, <span class="id">memval_inject</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ZMap.get</span> (<span class="id">lo</span> + <span class="id">ofs</span>) (<span class="id">fill_args_src_blk</span> <span class="id">m_tgt</span> (<span class="id">ZMap.init</span> <span class="id">Undef</span>) <span class="id">lo_tgt</span> <span class="id">lo</span> <span class="id">args</span> <span class="id">locs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ZMap.get</span> (<span class="id">lo_tgt</span> + <span class="id">ofs</span>) <span class="id">m_tgt</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6394')">Proof.</div>
<div class="proofscript" id="proof6394">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">args</span>. <span class="id">revert</span> <span class="id">m_tgt</span> <span class="id">args_tgt</span> <span class="id">ARGS</span>. <span class="tactic">induction</span> <span class="id">locs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">LENGTH</span>. <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">ZMap.gi</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">INJECT</span>. <span class="id">inv</span> <span class="id">LENGTH</span>. <span class="id">inv</span> <span class="id">ARGS</span>. <span class="tactic">unfold</span> <span class="id">fill_arg_src_blk</span>. <span class="id">des_ifs</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1:=<span class="id">ofs</span>). <span class="tactic">intros</span> <span class="id">INJ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exploit</span> <span class="id">Mem.setN_inj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">instantiate</span> (3:=<span class="id">j</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (2:=<span class="id">copy_list_memval</span> <span class="id">v</span> (<span class="id">Mem.getN</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)) (<span class="id">lo_tgt</span> + 4 * <span class="id">pos</span>) <span class="id">m_tgt</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1:=<span class="id">Mem.getN</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)) (<span class="id">lo_tgt</span> + 4 * <span class="id">pos</span>) <span class="id">m_tgt</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H5</span> <span class="id">pos</span> <span class="id">ty</span> <span class="id">eq_refl</span>). <span class="id">des</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">copy_list_memval_inject</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">instantiate</span> (4:=<span class="id">top1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (3:=<span class="id">fill_args_src_blk</span> <span class="id">m_tgt</span> (<span class="id">ZMap.init</span> <span class="id">Undef</span>) <span class="id">lo_tgt</span> <span class="id">lo</span> <span class="id">args</span> <span class="id">locs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1:=<span class="id">m_tgt</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1:=<span class="id">lo_tgt</span> - <span class="id">lo</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="id">exploit</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1:=<span class="id">q</span> - <span class="id">lo</span>). <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rpapply</span> <span class="id">H2</span>; <span class="tactic">f_equal</span>; <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">instantiate</span> (2:= <span class="id">lo</span> + <span class="id">ofs</span>). <span class="id">instantiate</span> (1:=<span class="id">lo</span> + 4 * <span class="id">pos</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">Z.add_0_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="id">rpapply</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">replace</span> (<span class="id">lo</span> + <span class="id">ofs</span> + (<span class="id">lo_tgt</span> - <span class="id">lo</span>)) <span class="kwd">with</span> (<span class="id">lo_tgt</span> + <span class="id">ofs</span>); <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">lo</span> + 4 * <span class="id">pos</span> + (<span class="id">lo_tgt</span> - <span class="id">lo</span>)) <span class="kwd">with</span> (<span class="id">lo_tgt</span> + 4 * <span class="id">pos</span>); <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">ofs</span>. <span class="tactic">clear</span> - <span class="id">m_tgt</span>. <span class="tactic">generalize</span> (4 * <span class="id">pos</span>). <span class="id">revert</span> <span class="id">m_tgt</span>. <span class="tactic">generalize</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">n</span>; <span class="id">ss</span>; <span class="id">i</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> &lt;- <span class="id">Z.add_assoc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">Mem.getN</span> <span class="id">n</span> (<span class="id">lo_tgt</span> + (<span class="id">z</span> + 1)) <span class="id">m_tgt</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.getN</span> <span class="id">n</span> (<span class="id">lo_tgt</span> + (<span class="id">z</span> + 1)) (<span class="id">ZMap.set</span> (<span class="id">lo_tgt</span> + <span class="id">z</span>) (<span class="id">ZMap.get</span> (<span class="id">lo_tgt</span> + <span class="id">z</span>) <span class="id">m_tgt</span>) <span class="id">m_tgt</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> &lt;- <span class="id">IHn</span>. <span class="tactic">rewrite</span> <span class="id">ZMap.gsspec</span>. <span class="id">des_ifs</span>. <span class="tactic">rewrite</span> <span class="id">e</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">clear</span> <span class="id">IHn</span>. <span class="tactic">generalize</span> <span class="id">z</span> <span class="id">m_tgt</span> (<span class="id">z</span>+1). <span class="tactic">induction</span> <span class="id">n</span>; <span class="id">ss</span>; <span class="id">i</span>. <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">ZMap.gsspec</span>. <span class="id">des_ifs</span>. <span class="tactic">rewrite</span> <span class="id">e</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">repeat</span> <span class="tactic">rewrite</span> &lt;- <span class="id">Z.add_assoc</span>. <span class="tactic">rewrite</span> <span class="id">IHn</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fill_args_src_blk_args</span> <span class="id">m_tgt</span> <span class="id">m</span> <span class="id">j</span> <span class="id">args_tgt</span> <span class="id">args</span> <span class="id">locs</span> <span class="id">lo_tgt</span> <span class="id">lo</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJECT</span>: <span class="id">Val.inject_list</span> <span class="id">j</span> <span class="id">args</span> <span class="id">args_tgt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOREPEAT</span>: <span class="id">Loc.norepet</span> (<span class="id">regs_of_rpairs</span> <span class="id">locs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LENGTH</span>: <span class="id">length</span> <span class="id">args</span> = <span class="id">length</span> <span class="id">locs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGS</span>: <span class="id">list_forall2</span> (<span class="id">extcall_arg_in_stack</span> <span class="id">m_tgt</span> <span class="id">lo_tgt</span>) <span class="id">locs</span> <span class="id">args_tgt</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> (<span class="id">extcall_arg_in_stack</span> (<span class="id">fill_args_src_blk</span> <span class="id">m_tgt</span> <span class="id">m</span> <span class="id">lo_tgt</span> <span class="id">lo</span> <span class="id">args</span> <span class="id">locs</span>) <span class="id">lo</span>) <span class="id">locs</span> <span class="id">args</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6395')">Proof.</div>
<div class="proofscript" id="proof6395">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">NOREPEAT</span> <span class="id">args_tgt</span> <span class="id">args</span> <span class="id">ARGS</span> <span class="id">INJECT</span> <span class="id">LENGTH</span>. <span class="tactic">induction</span> <span class="id">locs</span>; <span class="id">ss</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">LENGTH</span>. <span class="id">inv</span> <span class="id">ARGS</span>. <span class="id">inv</span> <span class="id">INJECT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">loc_norepet_app</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fill_arg_src_blk</span>. <span class="id">des_ifs</span>; <span class="tactic">try</span> (<span class="tactic">by</span> <span class="id">econs</span>; <span class="tactic">eauto</span>; <span class="id">ii</span>; <span class="id">inv</span> <span class="id">EQ</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="id">inv</span> <span class="id">EQ</span>. <span class="id">specialize</span> (<span class="id">H2</span> <span class="id">ofs</span> <span class="id">ty0</span> <span class="id">eq_refl</span>). <span class="id">des</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LEQ</span>: <span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty0</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Datatypes.length</span> (<span class="id">copy_list_memval</span> <span class="id">v</span> (<span class="id">Mem.getN</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty0</span>)) (<span class="id">lo_tgt</span> + 4 * <span class="id">ofs</span>) <span class="id">m_tgt</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">copy_list_memval</span>. <span class="tactic">rewrite</span> <span class="id">list_length_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Mem.getN_length</span>. <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">pattern</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty0</span>)) <span class="tactic">at</span> 1. <span class="tactic">rewrite</span> <span class="id">LEQ</span>. <span class="id">erewrite</span> <span class="id">Mem.getN_setN_same</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">copy_list_memval_decode</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Mem.getN_length</span>. <span class="tactic">destruct</span> <span class="id">ty0</span>; <span class="tactic">compute</span>; <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">list_forall2_lift</span>; [| <span class="tactic">eauto</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">clarify</span>. <span class="id">specialize</span> (<span class="id">H1</span> <span class="id">ofs</span> <span class="id">ty0</span> <span class="id">eq_refl</span>). <span class="id">des</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.getN_setN_outside</span>; <span class="tactic">eauto</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">NOREPEAT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Loc.in_notin_diff</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">in_one_in_rpair</span>; <span class="tactic">eauto</span>. } <span class="tactic">intros</span> <span class="id">DIFF</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">copy_list_memval</span> <span class="kwd">in</span> *. <span class="id">erewrite</span> <span class="id">map_length</span>. <span class="tactic">rewrite</span> <span class="id">Mem.getN_length</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> &lt;- <span class="id">size_chunk_conv</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">typesize_chunk</span>. <span class="id">des</span>; <span class="id">clarify</span>; <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fill_args_src_blk_default</span> <span class="id">m_tgt</span> <span class="id">m</span> <span class="id">args</span> <span class="id">locs</span> <span class="id">lo_tgt</span> <span class="id">lo</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fst</span> (<span class="id">fill_args_src_blk</span> <span class="id">m_tgt</span> <span class="id">m</span> <span class="id">lo_tgt</span> <span class="id">lo</span> <span class="id">args</span> <span class="id">locs</span>) = <span class="id">fst</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6396')">Proof.</div>
<div class="proofscript" id="proof6396">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">m</span> <span class="id">locs</span>. <span class="tactic">induction</span> <span class="id">args</span>; <span class="id">ss</span>; <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">fill_arg_src_blk</span>. <span class="id">des_ifs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Mem.setN_default</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Program</span> <span class="kwd">Definition</span> <span class="id">fill_args_src_mem</span> (<span class="id">m_tgt0</span> <span class="id">m_tgt1</span> : <span class="id">mem</span>) (<span class="id">m_src0</span>: <span class="id">mem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">args</span>: <span class="id">list</span> <span class="id">val</span>) (<span class="id">locs</span>: <span class="id">list</span> (<span class="id">rpair</span> <span class="id">loc</span>)) : <span class="id">mem</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.mkmem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PMap.set</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_src0</span>.(<span class="id">Mem.nextblock</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fill_args_src_blk</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_tgt1</span>.(<span class="id">Mem.mem_contents</span>) !! (<span class="id">m_tgt0</span>.(<span class="id">Mem.nextblock</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ZMap.init</span> <span class="id">Undef</span>) 0 0 <span class="id">args</span> <span class="id">locs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_src0</span>.(<span class="id">Mem.mem_contents</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PMap.set</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_src0</span>.(<span class="id">Mem.nextblock</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_tgt1</span>.(<span class="id">Mem.mem_access</span>) !! (<span class="id">m_tgt0</span>.(<span class="id">Mem.nextblock</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_src0</span>.(<span class="id">Mem.mem_access</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Pos.succ</span> <span class="id">m_src0</span>.(<span class="id">Mem.nextblock</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6397')">Next Obligation.</div>
<div class="proofscript" id="proof6397">
<div class="toggleproof" onclick="toggleDisplay('proof6398')">Proof.</div>
<div class="proofscript" id="proof6398">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span>. <span class="id">des_ifs</span>; <span class="tactic">eapply</span> <span class="id">Mem.access_max</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<div class="toggleproof" onclick="toggleDisplay('proof6399')">Next Obligation.</div>
<div class="proofscript" id="proof6399">
<div class="toggleproof" onclick="toggleDisplay('proof6400')">Proof.</div>
<div class="proofscript" id="proof6400">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exfalso</span>. <span class="tactic">eapply</span> <span class="id">H</span>. <span class="tactic">eapply</span> <span class="id">Plt_succ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Mem.nextblock_noaccess</span>. <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">H</span>. <span class="id">etrans</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Plt_succ</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<div class="toggleproof" onclick="toggleDisplay('proof6401')">Next Obligation.</div>
<div class="proofscript" id="proof6401">
<div class="toggleproof" onclick="toggleDisplay('proof6402')">Proof.</div>
<div class="proofscript" id="proof6402">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">fill_args_src_blk_default</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Mem.contents_default</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">encode_val</span>' (<span class="id">chunk</span>: <span class="id">memory_chunk</span>) (<span class="id">v</span>: <span class="id">val</span>) : <span class="id">list</span> <span class="id">memval</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">Val.eq</span> <span class="id">v</span> <span class="id">Vundef</span> <span class="kwd">then</span> <span class="id">list_repeat</span> (<span class="id">size_chunk_nat</span> <span class="id">chunk</span>) <span class="id">Undef</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">encode_val</span> <span class="id">chunk</span> <span class="id">v</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">encode_val_length</span>' <span class="id">chunk</span> <span class="id">v</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Datatypes.length</span> (<span class="id">encode_val</span>' <span class="id">chunk</span> <span class="id">v</span>) = <span class="id">size_chunk_nat</span> <span class="id">chunk</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6403')">Proof.</div>
<div class="proofscript" id="proof6403">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">encode_val</span>'. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">length_list_repeat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">encode_val_length</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">decode_encode_val</span>' <span class="id">ty</span> <span class="id">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TYP</span>: <span class="id">Val.has_type</span> <span class="id">v</span> <span class="id">ty</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">decode_val</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) (<span class="id">encode_val</span>' (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">v</span>) = <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6404')">Proof.</div>
<div class="proofscript" id="proof6404">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">encode_val</span>'. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">set</span> (<span class="id">size_chunk_nat_pos</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)). <span class="id">des</span>. <span class="tactic">rewrite</span> <span class="id">e</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">decode_val_undef</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> (<span class="id">decode_encode_val_general</span> <span class="id">v</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) (<span class="id">chunk_of_type</span> <span class="id">ty</span>)). <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">decode_encode_val_similar</span>; <span class="tactic">eauto</span>. <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">Val.load_result_same</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">fill_arg_blk</span> (<span class="id">m</span>: <span class="id">ZMap.t</span> <span class="id">memval</span>) (<span class="id">lo</span>: <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">arg</span>: <span class="id">val</span>) (<span class="id">loc</span>: <span class="id">rpair</span> <span class="id">loc</span>): <span class="id">ZMap.t</span> <span class="id">memval</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">loc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">One</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>) =&gt; <span class="id">Mem.setN</span> (<span class="id">encode_val</span>' (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">arg</span>) (<span class="id">lo</span> + 4 * <span class="id">ofs</span>) <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Fixpoint</span> <span class="id">fill_args_blk</span> (<span class="id">m</span>: <span class="id">ZMap.t</span> <span class="id">memval</span>) (<span class="id">lo</span>: <span class="id">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">args</span>: <span class="id">list</span> <span class="id">val</span>) (<span class="id">locs</span>: <span class="id">list</span> (<span class="id">rpair</span> <span class="id">loc</span>)): <span class="id">ZMap.t</span> <span class="id">memval</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">args</span>, <span class="id">locs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">vhd</span>::<span class="id">vtl</span>, <span class="id">lhd</span>::<span class="id">ltl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fill_arg_blk</span> (<span class="id">fill_args_blk</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">vtl</span> <span class="id">ltl</span>) <span class="id">lo</span> <span class="id">vhd</span> <span class="id">lhd</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">has_typed_loc</span> (<span class="id">l</span>: <span class="id">rpair</span> <span class="id">loc</span>) (<span class="id">v</span>: <span class="id">val</span>) :<span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">One</span> (<span class="id">S</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ty</span>) =&gt; <span class="id">Val.has_type</span> <span class="id">v</span> <span class="id">ty</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fill_args_blk_args</span> <span class="id">m</span> <span class="id">args</span> <span class="id">locs</span> <span class="id">lo</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOREPEAT</span>: <span class="id">Loc.norepet</span> (<span class="id">regs_of_rpairs</span> <span class="id">locs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ONES</span>: <span class="kwd">forall</span> <span class="id">l</span> (<span class="id">IN</span>: <span class="id">In</span> <span class="id">l</span> <span class="id">locs</span>), <span class="id">is_one</span> <span class="id">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LENGTH</span>: <span class="id">length</span> <span class="id">args</span> = <span class="id">length</span> <span class="id">locs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TYP</span>: <span class="id">list_forall2</span> <span class="id">has_typed_loc</span> <span class="id">locs</span> <span class="id">args</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> (<span class="id">extcall_arg_in_stack</span> (<span class="id">fill_args_blk</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">args</span> <span class="id">locs</span>) <span class="id">lo</span>) <span class="id">locs</span> <span class="id">args</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6405')">Proof.</div>
<div class="proofscript" id="proof6405">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">NOREPEAT</span> <span class="id">args</span> <span class="id">ONES</span> <span class="id">LENGTH</span> <span class="id">TYP</span>. <span class="tactic">induction</span> <span class="id">locs</span>; <span class="id">ss</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">LENGTH</span>. <span class="id">inv</span> <span class="id">TYP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">loc_norepet_app</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fill_arg_blk</span>. <span class="id">des_ifs</span>; <span class="tactic">try</span> (<span class="tactic">by</span> <span class="id">econs</span>; <span class="tactic">eauto</span>; <span class="id">ii</span>; <span class="id">inv</span> <span class="id">EQ</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">i</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LEQ</span>: <span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty0</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Datatypes.length</span> (<span class="id">encode_val</span>' (<span class="id">chunk_of_type</span> <span class="id">ty0</span>) <span class="id">v</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">encode_val_length</span>'. <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">LEQ</span> <span class="tactic">at</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.getN_setN_same</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">decode_encode_val</span>'; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">list_forall2_lift</span>; [| <span class="tactic">eauto</span>]. <span class="id">ii</span>. <span class="id">clarify</span>. <span class="id">specialize</span> (<span class="id">H1</span> <span class="id">ofs</span> <span class="id">ty0</span> <span class="id">eq_refl</span>). <span class="id">des</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.getN_setN_outside</span>; <span class="tactic">eauto</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">NOREPEAT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Loc.in_notin_diff</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">in_one_in_rpair</span>; <span class="tactic">eauto</span>. } <span class="tactic">intros</span> <span class="id">DIFF</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">encode_val_length</span>'. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> &lt;- <span class="id">size_chunk_conv</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">typesize_chunk</span>. <span class="id">des</span>; <span class="id">clarify</span>; <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fill_args_blk_only_args</span> <span class="id">args</span> <span class="id">locs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOREPEAT</span>: <span class="id">Loc.norepet</span> (<span class="id">regs_of_rpairs</span> <span class="id">locs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LENGTH</span>: <span class="id">length</span> <span class="id">args</span> = <span class="id">length</span> <span class="id">locs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ONES</span>: <span class="kwd">forall</span> <span class="id">l</span> (<span class="id">IN</span>: <span class="id">In</span> <span class="id">l</span> <span class="id">locs</span>), <span class="id">is_one</span> <span class="id">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TYP</span>: <span class="id">list_forall2</span> <span class="id">has_typed_loc</span> <span class="id">locs</span> <span class="id">args</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">only_args_blk</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fill_args_blk</span> (<span class="id">ZMap.init</span> <span class="id">Undef</span>) 0 <span class="id">args</span> <span class="id">locs</span>) (<span class="id">regs_of_rpairs</span> <span class="id">locs</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6406')">Proof.</div>
<div class="proofscript" id="proof6406">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">args</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">NOREPEAT</span> <span class="id">ONES</span>. <span class="tactic">induction</span> <span class="id">locs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">LENGTH</span>. <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">ii</span>. <span class="tactic">rewrite</span> <span class="id">ZMap.gi</span>. <span class="id">left</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">TYP</span>. <span class="id">inv</span> <span class="id">LENGTH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">loc_norepet_app</span>; <span class="tactic">eauto</span>. } <span class="tactic">intros</span> <span class="id">ONLY</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fill_arg_blk</span>. <span class="id">des_ifs</span>; <span class="tactic">try</span> (<span class="tactic">by</span> <span class="tactic">eapply</span> <span class="id">only_args_blk_incr</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ss</span>. <span class="id">ii</span>. <span class="tactic">destruct</span> (<span class="id">classic</span> (4 * <span class="id">pos</span> &lt;= <span class="id">ofs</span> &lt; 4 * <span class="id">pos</span> + <span class="id">Z.of_nat</span> (<span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">assert</span> (<span class="id">LEQ</span>: <span class="id">size_chunk_nat</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Datatypes.length</span> (<span class="id">encode_val</span>' (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">v</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">encode_val_length</span>'. } <span class="id">exploit</span> <span class="id">Mem.getN_in</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">LEQ</span> <span class="tactic">at</span> 1. <span class="tactic">rewrite</span> <span class="id">Mem.getN_setN_same</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1:=<span class="id">fill_args_blk</span> (<span class="id">ZMap.init</span> <span class="id">Undef</span>) 0 <span class="id">args</span> <span class="id">locs</span>). <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">v</span> = <span class="id">Vundef</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">clarify</span>. <span class="tactic">unfold</span> <span class="id">encode_val</span>' <span class="kwd">in</span> *. <span class="id">des_ifs</span>. <span class="tactic">eapply</span> <span class="id">in_list_repeat</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="id">left</span>. <span class="id">econs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">right</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ss</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">size_chunk_conv</span> <span class="kwd">in</span> *. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">LEQ</span> <span class="tactic">at</span> 1. <span class="id">erewrite</span> <span class="id">Mem.getN_setN_same</span>. <span class="tactic">rewrite</span> <span class="id">decode_encode_val</span>'; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">specialize</span> (<span class="id">ONLY</span> <span class="id">ofs</span>). <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">left</span>. <span class="id">erewrite</span> <span class="id">Mem.setN_other</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">encode_val_length</span>'. <span class="id">ii</span>. <span class="id">clarify</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">right</span>. <span class="id">esplits</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>. <span class="id">erewrite</span> <span class="id">Mem.getN_setN_outside</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">encode_val_length</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> &lt;- <span class="id">size_chunk_conv</span> <span class="kwd">in</span> *. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">typesize_chunk</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty0</span>). <span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">NOREPEAT</span>. <span class="id">exploit</span> <span class="id">Loc.in_notin_diff</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">ss</span>. <span class="id">des</span>; <span class="id">clarify</span>; <span class="id">lia</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ss</span>. <span class="id">exploit</span> <span class="id">ONES</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">fill_args_blk_default</span> <span class="id">m</span> <span class="id">args</span> <span class="id">locs</span> <span class="id">lo</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fst</span> (<span class="id">fill_args_blk</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">args</span> <span class="id">locs</span>) = <span class="id">fst</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6407')">Proof.</div>
<div class="proofscript" id="proof6407">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">m</span> <span class="id">locs</span>. <span class="tactic">induction</span> <span class="id">args</span>; <span class="id">ss</span>; <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">fill_arg_blk</span>. <span class="id">des_ifs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Mem.setN_default</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Program</span> <span class="kwd">Definition</span> <span class="id">fill_args_mem</span> (<span class="id">m_src0</span>: <span class="id">mem</span>) (<span class="id">blk</span>: <span class="id">block</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">args</span>: <span class="id">list</span> <span class="id">val</span>) (<span class="id">locs</span>: <span class="id">list</span> (<span class="id">rpair</span> <span class="id">loc</span>)) : <span class="id">mem</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.mkmem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PMap.set</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">blk</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fill_args_blk</span> (<span class="id">ZMap.init</span> <span class="id">Undef</span>) 0 <span class="id">args</span> <span class="id">locs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_src0</span>.(<span class="id">Mem.mem_contents</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_src0</span>.(<span class="id">Mem.mem_access</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_src0</span>.(<span class="id">Mem.nextblock</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">_</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6408')">Next Obligation.</div>
<div class="proofscript" id="proof6408">
<div class="toggleproof" onclick="toggleDisplay('proof6409')">Proof.</div>
<div class="proofscript" id="proof6409">
 <span class="tactic">eapply</span> <span class="id">Mem.access_max</span>. Qed.</div>
<div class="toggleproof" onclick="toggleDisplay('proof6410')">Next Obligation.</div>
<div class="proofscript" id="proof6410">
<div class="toggleproof" onclick="toggleDisplay('proof6411')">Proof.</div>
<div class="proofscript" id="proof6411">
 <span class="tactic">eapply</span> <span class="id">Mem.nextblock_noaccess</span>; <span class="tactic">auto</span>. Qed.</div>
<div class="toggleproof" onclick="toggleDisplay('proof6412')">Next Obligation.</div>
<div class="proofscript" id="proof6412">
<div class="toggleproof" onclick="toggleDisplay('proof6413')">Proof.</div>
<div class="proofscript" id="proof6413">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">fill_args_blk_default</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Mem.contents_default</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">_FillArgsParallel</span>.<br/>
<br/>
<br/>
<span class="kwd">Section</span> <span class="id">STOREARGPRARALLEL</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Theorem</span> <span class="id">store_arguments_parallel_inject</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span> <span class="id">m_src0</span> <span class="id">m_tgt0</span> <span class="id">m_tgt1</span> <span class="id">rs_tgt</span> <span class="id">vs</span> <span class="id">vs</span>' <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TYP</span>: <span class="id">Val.has_type_list</span> <span class="id">vs</span>' <span class="id">sg</span>.(<span class="id">sig_args</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SZ</span>: 4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">Ptrofs.max_unsigned</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VALINJ</span>: <span class="id">Val.inject_list</span> <span class="id">j</span> <span class="id">vs</span> <span class="id">vs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJ</span>: <span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m_src0</span> <span class="id">m_tgt0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGSRC</span>: <span class="id">store_arguments</span> <span class="id">m_tgt0</span> <span class="id">rs_tgt</span> <span class="id">vs</span>' <span class="id">sg</span> <span class="id">m_tgt1</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">m_src1</span> <span class="id">rs_src</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">ARGTGT</span>: <span class="id">store_arguments</span> <span class="id">m_src0</span> <span class="id">rs_src</span> <span class="id">vs</span> <span class="id">sg</span> <span class="id">m_src1</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">INJ</span>: <span class="id">Mem.inject</span> (<span class="id">update_meminj</span> <span class="id">j</span> (<span class="id">Mem.nextblock</span> <span class="id">m_src0</span>) (<span class="id">Mem.nextblock</span> <span class="id">m_tgt0</span>) 0) <span class="id">m_src1</span> <span class="id">m_tgt1</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">AGREE</span>: <span class="id">agree</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">update_meminj</span> <span class="id">j</span> (<span class="id">Mem.nextblock</span> <span class="id">m_src0</span>) (<span class="id">Mem.nextblock</span> <span class="id">m_tgt0</span>) 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rs_src</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rs_tgt</span>&gt;&gt;).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6414')">Proof.</div>
<div class="proofscript" id="proof6414">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">_FillArgsParallel.fill_args_src_mem</span> <span class="id">m_tgt0</span> <span class="id">m_tgt1</span> <span class="id">m_src0</span> <span class="id">vs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">_FillArgsParallel.fill_args_src_reg</span> <span class="id">vs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.alloc</span> <span class="id">m_src0</span> 0 (4 * <span class="id">size_arguments</span> <span class="id">sg</span>)) <span class="id">eqn</span>:<span class="id">ALLOC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dup</span> <span class="id">ALLOC</span>. <span class="tactic">apply</span> <span class="id">Mem.alloc_result</span> <span class="kwd">in</span> <span class="id">ALLOC0</span>. <span class="id">clarify</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">ARGSRC</span>. <span class="tactic">unfold</span> <span class="id">extcall_arguments</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dup</span> <span class="id">ALC</span>. <span class="tactic">apply</span> <span class="id">Mem.alloc_result</span> <span class="kwd">in</span> <span class="id">ALC0</span>. <span class="id">clarify</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">INC</span> : <span class="id">inject_incr</span> <span class="id">j</span> (<span class="id">update_meminj</span> <span class="id">j</span> (<span class="id">Mem.nextblock</span> <span class="id">m_src0</span>) (<span class="id">Mem.nextblock</span> <span class="id">m_tgt0</span>) 0)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">update_meminj</span> <span class="kwd">in</span> *. <span class="id">ii</span>. <span class="id">des_ifs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exfalso</span>. <span class="id">inv</span> <span class="id">INJ</span>. <span class="id">exploit</span> <span class="id">mi_freeblocks</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">instantiate</span> (1:=(<span class="id">Mem.nextblock</span> <span class="id">m_src0</span>)). <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span>. <span class="tactic">eapply</span> <span class="id">Plt_strict</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>. <span class="id">clarify</span>. }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">splits</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">extcall_arguments</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LENGTH</span>: <span class="id">Datatypes.length</span> <span class="id">vs</span> = <span class="id">Datatypes.length</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">erewrite</span> <span class="id">inject_list_length</span>; <span class="tactic">eauto</span>. <span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">list_forall2_length</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">_FillArgsParallel.fill_args_src_reg_args</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">loc_arguments_norepet</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">loc_arguments_one</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">_FillArgsParallel.fill_args_src_blk_args</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">loc_arguments_norepet</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">extcall_arguments_extcall_arg_in_stack</span>; <span class="tactic">eauto</span>. <span class="id">lia</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1:= 0). <span class="id">instantiate</span> (1:=<span class="id">ZMap.init</span> <span class="id">Undef</span>). <span class="tactic">intros</span> <span class="id">STACK</span> <span class="id">REGS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">extcall_arg_in_stack_in_reg_extcall_argument</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">_FillArgsParallel.fill_args_src_mem</span>, <span class="id">Mem.range_perm</span>, <span class="id">Mem.perm</span>. <span class="id">ss</span>. <span class="id">ii</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="id">exploit</span> <span class="id">PERM</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="id">exploit</span> <span class="id">_FillArgsParallel.fill_args_src_blk_only_args</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">loc_arguments_norepet</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">erewrite</span> <span class="id">inject_list_length</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Val_has_type_list_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">loc_arguments_one</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">extcall_arguments_extcall_arg_in_stack</span>; <span class="tactic">eauto</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">i</span>. <span class="id">instantiate</span> (1:=<span class="id">ofs</span>) <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">_FillArgsParallel.fill_args_src_mem</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">Mem.load</span>. <span class="tactic">unfold</span> <span class="id">Mem.load</span>. <span class="id">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="id">des</span>; <span class="tactic">eauto</span>. <span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">loc_arguments_acceptable_2</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">loc_arguments_bounded</span>; <span class="tactic">eauto</span>. <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">hexploit</span> <span class="id">loc_arguments_bounded</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>). <span class="id">lia</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>. <span class="id">exfalso</span>. <span class="tactic">apply</span> <span class="id">n</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_access</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.perm_cur</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_implies</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">PERM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">erewrite</span> <span class="id">typesize_chunk</span> <span class="kwd">in</span> *. <span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>). <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">econs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">clear</span> - <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">Z.divide_factor_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Z.mul_divide_mono_l</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">instantiate</span> (1:=4) <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">ss</span>. }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">dup</span> <span class="id">ALLOC</span>. <span class="tactic">eapply</span> <span class="id">Mem.alloc_unchanged_on</span> <span class="kwd">with</span> (<span class="id">P</span>:=<span class="id">top2</span>) <span class="kwd">in</span> <span class="id">ALLOC0</span>. <span class="id">inv</span> <span class="id">ALLOC0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">erewrite</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="id">refl</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">i</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">split</span>; <span class="id">i</span>; <span class="id">exfalso</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_3</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">_FillArgsParallel.fill_args_src_mem</span>, <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gss</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_unchanged_on_2</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_3</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">ss</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Mem.valid_new_block</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">transitivity</span> (<span class="id">Mem.perm</span> <span class="id">m_src0</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">unchanged_on_perm</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="id">erewrite</span> <span class="id">Mem.nextblock_alloc</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Plt_succ_inv</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">des</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">Mem.perm</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gso</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">i</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="id">exfalso</span>. <span class="id">exploit</span> <span class="id">Mem.perm_alloc_3</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">ALLOC</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">PMap.gso</span>; <span class="tactic">eauto</span>. <span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">unchanged_on_contents</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_4</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="tactic">eapply</span> <span class="id">PERM</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">INJ</span>. <span class="id">inv</span> <span class="id">mi_inj</span>. <span class="tactic">unfold</span> <span class="id">_FillArgsParallel.fill_args_src_mem</span>, <span class="id">update_meminj</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">econs</span>; <span class="id">ss</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="id">zsimpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">UNCH</span>. <span class="tactic">eapply</span> <span class="id">unchanged_on_perm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">des_ifs</span>. <span class="id">exploit</span> <span class="id">mi_mappedblocks</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">Plt_strict</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">exploit</span> <span class="id">mi_mappedblocks</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_block_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_1</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Z.divide_0_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">mi_align</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Mem.range_perm</span>, <span class="id">Mem.perm</span> <span class="kwd">in</span> *; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">H0</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">memval_inject_incr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">hexploit</span> <span class="id">_FillArgsParallel.fill_args_src_blk_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">erewrite</span> <span class="id">inject_list_length</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Val_has_type_list_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">extcall_arguments_extcall_arg_in_stack</span>; <span class="tactic">eauto</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">instantiate</span> (1:= <span class="id">ofs</span>). <span class="tactic">rewrite</span> <span class="id">Z.add_0_r</span>. <span class="tactic">intros</span> <span class="id">VINJ</span>. <span class="id">erewrite</span> <span class="id">Z.add_0_l</span> <span class="kwd">in</span> *. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">dup</span> <span class="id">ALC</span>. <span class="tactic">eapply</span> <span class="id">Mem.alloc_unchanged_on</span> <span class="kwd">with</span> (<span class="id">P</span>:=<span class="id">top2</span>) <span class="kwd">in</span> <span class="id">ALC0</span>. <span class="id">inv</span> <span class="id">ALC0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">mi_memval</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *; <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* { <span class="id">i</span>. <span class="id">inv</span> <span class="id">UNCH</span>. <span class="tactic">rewrite</span> <span class="id">unchanged_on_contents0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">unchanged_on_contents</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">des_ifs</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mi_mappedblocks</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="tactic">eapply</span> <span class="id">Plt_strict</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">mi_perm</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *; <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">i</span>. <span class="tactic">eapply</span> <span class="id">unchanged_on_perm</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exfalso</span>. <span class="tactic">eapply</span> <span class="id">H</span>. <span class="tactic">eapply</span> <span class="id">Plt_succ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">mi_freeblocks</span>. <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">H</span>. <span class="id">etrans</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Plt_succ</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Mem.valid_new_block</span> <span class="kwd">in</span> <span class="id">ALC</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> &lt;- <span class="id">NB</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">mi_mappedblocks</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">NB</span>. <span class="id">i</span>. <span class="id">etrans</span>; <span class="tactic">eauto</span>. <span class="id">erewrite</span> (<span class="id">Mem.nextblock_alloc</span>) <span class="kwd">with</span> (<span class="id">m2</span> := <span class="id">m1</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_succ</span>. }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="id">des_ifs</span>; <span class="id">ss</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">left</span>. <span class="id">ii</span>. <span class="id">clarify</span>. <span class="id">exploit</span> <span class="id">mi_mappedblocks</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">left</span>. <span class="id">ii</span>. <span class="id">clarify</span>. <span class="id">exploit</span> <span class="id">mi_mappedblocks</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">mi_no_overlap</span> <span class="kwd">with</span> (<span class="id">b1</span> := <span class="id">b1</span>) (<span class="id">b2</span> := <span class="id">b2</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">set</span> (<span class="id">Ptrofs.unsigned_range_2</span> <span class="id">ofs</span>). <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">mi_representable</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">Z.add_0_r</span> <span class="kwd">in</span> *. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">mi_perm_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">UNCH</span>. <span class="tactic">apply</span> <span class="id">unchanged_on_perm</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_4</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">mi_mappedblocks</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="tactic">eapply</span> <span class="id">Plt_strict</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">des_ifs</span>. <span class="id">exploit</span> <span class="id">mi_mappedblocks</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="tactic">eapply</span> <span class="id">Plt_strict</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">exploit</span> <span class="id">mi_mappedblocks</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="id">etrans</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">Plt_succ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">hexploit</span> <span class="id">_FillArgsParallel.fill_args_src_reg_agree</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">erewrite</span> <span class="id">inject_list_length</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Val_has_type_list_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">extcall_arguments_extcall_arg_in_reg</span>; <span class="tactic">eauto</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="id">cinv</span> (<span class="id">H</span> <span class="id">mr</span>); <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Theorem</span> <span class="id">store_arguments_parallel_extends</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m_src0</span> <span class="id">m_tgt0</span> <span class="id">m_tgt1</span> <span class="id">rs_tgt</span> <span class="id">vs</span> <span class="id">vs</span>' <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TYP</span>: <span class="id">Val.has_type_list</span> <span class="id">vs</span>' <span class="id">sg</span>.(<span class="id">sig_args</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SZ</span>: 4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">Ptrofs.max_unsigned</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VALINJ</span>: <span class="id">Val.lessdef_list</span> <span class="id">vs</span> <span class="id">vs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXTENDS</span>: <span class="id">Mem.extends</span> <span class="id">m_src0</span> <span class="id">m_tgt0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGSRC</span>: <span class="id">store_arguments</span> <span class="id">m_tgt0</span> <span class="id">rs_tgt</span> <span class="id">vs</span>' <span class="id">sg</span> <span class="id">m_tgt1</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">m_src1</span> <span class="id">rs_src</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">ARGTGT</span>: <span class="id">store_arguments</span> <span class="id">m_src0</span> <span class="id">rs_src</span> <span class="id">vs</span> <span class="id">sg</span> <span class="id">m_src1</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">EXTENDS</span>: <span class="id">Mem.extends</span> <span class="id">m_src1</span> <span class="id">m_tgt1</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">AGREE</span>: <span class="id">agree</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inject_id</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rs_src</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rs_tgt</span>&gt;&gt;).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6415')">Proof.</div>
<div class="proofscript" id="proof6415">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">_FillArgsParallel.fill_args_src_mem</span> <span class="id">m_tgt0</span> <span class="id">m_tgt1</span> <span class="id">m_src0</span> <span class="id">vs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">_FillArgsParallel.fill_args_src_reg</span> <span class="id">vs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.alloc</span> <span class="id">m_src0</span> 0 (4 * <span class="id">size_arguments</span> <span class="id">sg</span>)) <span class="id">eqn</span>:<span class="id">ALLOC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dup</span> <span class="id">ALLOC</span>. <span class="tactic">apply</span> <span class="id">Mem.alloc_result</span> <span class="kwd">in</span> <span class="id">ALLOC0</span>. <span class="id">clarify</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">ARGSRC</span>. <span class="tactic">unfold</span> <span class="id">extcall_arguments</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dup</span> <span class="id">ALC</span>. <span class="tactic">apply</span> <span class="id">Mem.alloc_result</span> <span class="kwd">in</span> <span class="id">ALC0</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">val_inject_list_lessdef</span> <span class="kwd">in</span> <span class="id">VALINJ</span>. <span class="id">splits</span>; <span class="id">ss</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">extcall_arguments</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LENGTH</span>: <span class="id">Datatypes.length</span> <span class="id">vs</span> = <span class="id">Datatypes.length</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">erewrite</span> <span class="id">inject_list_length</span>; <span class="tactic">eauto</span>. <span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">list_forall2_length</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">_FillArgsParallel.fill_args_src_reg_args</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">loc_arguments_norepet</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">loc_arguments_one</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">_FillArgsParallel.fill_args_src_blk_args</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">loc_arguments_norepet</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">extcall_arguments_extcall_arg_in_stack</span>; <span class="tactic">eauto</span>. <span class="id">lia</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1:=0). <span class="id">instantiate</span> (1:=<span class="id">ZMap.init</span> <span class="id">Undef</span>). <span class="tactic">intros</span> <span class="id">STACK</span> <span class="id">REGS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">extcall_arg_in_stack_in_reg_extcall_argument</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">_FillArgsParallel.fill_args_src_mem</span>, <span class="id">Mem.range_perm</span>, <span class="id">Mem.perm</span>. <span class="id">ss</span>. <span class="id">ii</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="id">exploit</span> <span class="id">PERM</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="id">exploit</span> <span class="id">_FillArgsParallel.fill_args_src_blk_only_args</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">loc_arguments_norepet</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">erewrite</span> <span class="id">inject_list_length</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Val_has_type_list_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">loc_arguments_one</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">extcall_arguments_extcall_arg_in_stack</span>; <span class="tactic">eauto</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">i</span>. <span class="id">instantiate</span> (1:=<span class="id">ofs</span>) <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">_FillArgsParallel.fill_args_src_mem</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">Mem.load</span>. <span class="tactic">unfold</span> <span class="id">Mem.load</span>. <span class="id">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="id">des</span>; <span class="tactic">eauto</span>. <span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">loc_arguments_acceptable_2</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">loc_arguments_bounded</span>; <span class="tactic">eauto</span>. <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">hexploit</span> <span class="id">loc_arguments_bounded</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>). <span class="id">lia</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>. <span class="id">exfalso</span>. <span class="tactic">apply</span> <span class="id">n</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_access</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.perm_cur</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_implies</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">PERM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">erewrite</span> <span class="id">typesize_chunk</span> <span class="kwd">in</span> *. <span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>). <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">econs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">clear</span> - <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">Z.divide_factor_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Z.mul_divide_mono_l</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">instantiate</span> (1:=4) <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">dup</span> <span class="id">ALLOC</span>. <span class="tactic">eapply</span> <span class="id">Mem.alloc_unchanged_on</span> <span class="kwd">with</span> (<span class="id">P</span>:=<span class="id">top2</span>) <span class="kwd">in</span> <span class="id">ALLOC0</span>. <span class="id">inv</span> <span class="id">ALLOC0</span>. <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">erewrite</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="id">refl</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">i</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">split</span>; <span class="id">i</span>; <span class="id">exfalso</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_3</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">_FillArgsParallel.fill_args_src_mem</span>, <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gss</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_unchanged_on_2</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_3</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">ss</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Mem.valid_new_block</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">transitivity</span> (<span class="id">Mem.perm</span> <span class="id">m_src0</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">unchanged_on_perm</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.nextblock_alloc</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Plt_succ_inv</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">des</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">Mem.perm</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gso</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">i</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="id">exfalso</span>. <span class="id">exploit</span> <span class="id">Mem.perm_alloc_3</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">ALLOC</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">PMap.gso</span>; <span class="tactic">eauto</span>. <span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">unchanged_on_contents</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_4</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="tactic">eapply</span> <span class="id">PERM</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">_FillArgsParallel.fill_args_src_mem</span>. <span class="id">inv</span> <span class="id">EXTENDS</span>. <span class="id">inv</span> <span class="id">mext_inj</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">mext_next</span>. <span class="id">erewrite</span> &lt;- <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">inject_id</span> <span class="kwd">in</span> *.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">econs</span>; <span class="id">ss</span>; <span class="id">i</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">zsimpl</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">b2</span> (<span class="id">Mem.nextblock</span> <span class="id">m_src0</span>)); <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">mext_next</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">UNCH</span>. <span class="tactic">eapply</span> <span class="id">unchanged_on_perm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">des_ifs</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Mem.perm_valid_block</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mi_perm</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_1</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="id">exploit</span> <span class="id">mi_perm</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">zsimpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Z.divide_0_r</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">hexploit</span> <span class="id">_FillArgsParallel.fill_args_src_blk_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">erewrite</span> <span class="id">inject_list_length</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Val_has_type_list_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">extcall_arguments_extcall_arg_in_stack</span>; <span class="tactic">eauto</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">instantiate</span> (1:= <span class="id">ofs</span>). <span class="id">erewrite</span> <span class="id">Z.add_0_r</span>. <span class="id">erewrite</span> <span class="id">Z.add_0_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">VINJ</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">mext_next</span> <span class="kwd">in</span> *. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">mi_memval</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">zsimpl</span>. <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">UNCH</span>. <span class="id">dup</span> <span class="id">ALC</span>. <span class="tactic">eapply</span> <span class="id">Mem.alloc_unchanged_on</span> <span class="kwd">with</span> (<span class="id">P</span>:=<span class="id">top2</span>) <span class="kwd">in</span> <span class="id">ALC0</span>. <span class="id">inv</span> <span class="id">ALC0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">unchanged_on_contents</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">unchanged_on_contents0</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="id">exploit</span> <span class="id">mi_perm</span>; <span class="tactic">eauto</span>. <span class="id">zsimpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">des_ifs</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">unchanged_on_perm0</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.perm_valid_block</span>. <span class="id">exploit</span> <span class="id">mi_perm</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *; <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">mi_perm</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *; <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">zsimpl</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ { <span class="id">ii</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m_src0</span>)); <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">mext_next</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">mext_perm_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">UNCH</span>. <span class="tactic">apply</span> <span class="id">unchanged_on_perm</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_4</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="id">clarify</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">des_ifs</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Mem.perm_valid_block</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> <span class="id">NB</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">hexploit</span> <span class="id">_FillArgsParallel.fill_args_src_reg_agree</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">erewrite</span> <span class="id">inject_list_length</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Val_has_type_list_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">extcall_arguments_extcall_arg_in_reg</span>; <span class="tactic">eauto</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="id">cinv</span> (<span class="id">H</span> <span class="id">mr</span>); <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">STOREARGPRARALLEL</span>.<br/>
<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">JunkBlock</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">typify_has_typed_loc</span> <span class="id">vs</span> <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TYP</span> : <span class="id">Val.has_type_list</span> <span class="id">vs</span> (<span class="id">sig_args</span> <span class="id">sg</span>)):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">_FillArgsParallel.has_typed_loc</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>) <span class="id">vs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6416')">Proof.</div>
<div class="proofscript" id="proof6416">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sig_args</span>, <span class="id">loc_arguments</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> 0 <span class="tactic">at</span> 1. <span class="tactic">generalize</span> 0 <span class="tactic">at</span> 1. <span class="tactic">generalize</span> 0 <span class="tactic">at</span> 1.<br/>
&nbsp;&nbsp;<span class="id">revert</span> <span class="id">TYP</span>. <span class="tactic">clear</span>. <span class="id">ginduction</span> <span class="id">sig_args</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;- <span class="id">i</span>. <span class="tactic">destruct</span> <span class="id">vs</span>; <span class="id">clarify</span>. <span class="id">econs</span>.<br/>
&nbsp;&nbsp;- <span class="id">i</span>. <span class="tactic">destruct</span> <span class="id">vs</span>; <span class="id">clarify</span>. <span class="id">ss</span>. <span class="id">des</span>. <span class="id">des_ifs</span>; <span class="id">econs</span>; <span class="tactic">eauto</span>; <span class="tactic">try</span> <span class="tactic">by</span> <span class="id">econs</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">store_arguments_progress</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m0</span> <span class="id">tvs</span> <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TYP</span>: <span class="id">Val.has_type_list</span> <span class="id">tvs</span> <span class="id">sg</span>.(<span class="id">sig_args</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SZ</span>: 4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">Ptrofs.max_unsigned</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">STR</span>: <span class="id">store_arguments</span> <span class="id">m0</span> <span class="id">rs</span> <span class="id">tvs</span> <span class="id">sg</span> <span class="id">m2</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">PTRFREE</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NIN</span>: ~ <span class="id">In</span> (<span class="id">R</span> <span class="id">mr</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>))),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_junk_value</span> <span class="id">m2</span> (<span class="id">assign_junk_blocks</span> <span class="id">m2</span> <span class="id">n</span>) (<span class="id">rs</span> <span class="id">mr</span>)&gt;&gt;).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6417')">Proof.</div>
<div class="proofscript" id="proof6417">
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.alloc</span> <span class="id">m0</span> 0 (4 * <span class="id">size_arguments</span> <span class="id">sg</span>)) <span class="id">eqn</span>:<span class="id">ALC</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="kwd">fun</span> <span class="id">mr</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">extcall_args_reg</span> <span class="id">mr</span> <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> (<span class="id">_FillArgsParallel.fill_args_src_reg</span> <span class="id">tvs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)) <span class="id">mr</span> <span class="kwd">else</span> <span class="id">Vundef</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">_FillArgsParallel.fill_args_mem</span> <span class="id">m</span> <span class="id">b</span> <span class="id">tvs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)).<br/>
&nbsp;&nbsp;<span class="id">splits</span>.<br/>
&nbsp;&nbsp;- <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">extcall_arguments_same</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">extcall_arg_in_stack_in_reg_extcall_argument</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">_FillArgsParallel.fill_args_blk_args</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">loc_arguments_norepet</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">loc_arguments_one</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Val_has_type_list_length</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">typify_has_typed_loc</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">_FillArgsParallel.fill_args_src_reg_args</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">loc_arguments_norepet</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">loc_arguments_one</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Val_has_type_list_length</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Mem_alloc_range_perm</span> <span class="kwd">in</span> <span class="id">ALC</span>. <span class="tactic">unfold</span> <span class="id">Mem.range_perm</span>, <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">i</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="id">exploit</span> <span class="id">_FillArgsParallel.fill_args_blk_only_args</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">loc_arguments_norepet</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">Val_has_type_list_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">loc_arguments_one</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">typify_has_typed_loc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">i</span>. <span class="id">instantiate</span> (1:=<span class="id">ofs</span>) <span class="kwd">in</span> <span class="id">H</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">Mem.load</span>. <span class="tactic">unfold</span> <span class="id">Mem.load</span>. <span class="id">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="id">des</span>; <span class="tactic">eauto</span>. <span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">loc_arguments_acceptable_2</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">loc_arguments_bounded</span>; <span class="tactic">eauto</span>. <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">hexploit</span> <span class="id">loc_arguments_bounded</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>). <span class="id">lia</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>. <span class="id">exfalso</span>. <span class="tactic">apply</span> <span class="id">n0</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_access</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Mem.perm</span>. <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_cur</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_implies</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">erewrite</span> <span class="id">typesize_chunk</span> <span class="kwd">in</span> *. <span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>). <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">econs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">clear</span> - <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">Z.divide_factor_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Z.mul_divide_mono_l</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">instantiate</span> (1:=4) <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="id">refl</span>. <span class="id">i</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span>. <span class="id">des_ifs</span>; <span class="id">ss</span>. <span class="id">exfalso</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">H</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_3</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem_alloc_range_perm</span> <span class="kwd">in</span> <span class="id">ALC</span>. <span class="tactic">unfold</span> <span class="id">Mem.range_perm</span>, <span class="id">Mem.perm</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;- <span class="id">i</span>. <span class="id">des_ifs</span>.<br/>
Qed.</div>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</div>
</body>
</html>
