
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module DemoSpecProof</title>
<meta name="description" content="Documentation of Coq module DemoSpecProof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module DemoSpecProof</h1>
<div class="coq">
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">CoqlibC</span> <span class="id">Maps</span> <span class="id">Postorder</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ValuesC</span> <span class="id">Memory</span> <span class="id">Globalenvs</span> <span class="id">Events</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Csyntax</span> <span class="id">AsmC</span> <span class="id">AsmExtra</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">sflib</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Export</span> <span class="id">Renumberproof</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Simulation</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Skeleton</span> <span class="id">Mod</span> <span class="id">ModSem</span> <span class="id">SimMod</span> <span class="id">SimModSem</span> <span class="id">SimSymb</span> <span class="id">SimMem</span> <span class="id">AsmregsC</span> <span class="id">MatchSimModSem</span>.<br/>
<span class="kwd">Require</span> <span class="id">SimMemInjC</span>.<br/>
<span class="kwd">Require</span> <span class="id">SoundTop</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">MatchSimModSem</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="id">DemoSpec</span>.<br/>
<span class="kwd">Require</span> <span class="id">DemoTarget</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">DemoHeader</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Floats</span> <span class="id">Integers</span> <span class="id">IntegersC</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Fappli_rnd_odd</span>.<br/>
<span class="kwd">Definition</span> <span class="id">round_to_odd</span> (<span class="id">v</span>: <span class="id">val</span>): <span class="id">val</span> := <span class="id">Val.orl</span> (<span class="id">Val.shrlu</span> <span class="id">v</span> (<span class="id">Vint</span> <span class="id">Int.one</span>)) (<span class="id">Val.andl</span> <span class="id">v</span> (<span class="id">Vlong</span> <span class="id">Int64.one</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">arithmetic_fact</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">l</span><br/>
&nbsp;&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Val.floatoflongu</span> (<span class="id">Vlong</span> <span class="id">l</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">zlt</span> <span class="id">l</span>.(<span class="id">Int64.unsigned</span>) <span class="id">Int64.half_modulus</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">Val.floatoflong</span> (<span class="id">Vlong</span> <span class="id">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Val.floatoflong</span> (<span class="id">round_to_odd</span> (<span class="id">Vlong</span> <span class="id">l</span>)) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">half</span> =&gt; <span class="id">Some</span> (<span class="id">Val.addf</span> <span class="id">half</span> <span class="id">half</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6330')">Proof.</div>
<div class="proofscript" id="proof6330">
&nbsp;&nbsp;<span class="id">ss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">Int64.unsigned</span> <span class="id">l</span> &lt; 2 ^ 53)).<br/>
&nbsp;&nbsp;{ <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">T</span>: <span class="id">zlt</span> (<span class="id">Int64.unsigned</span> <span class="id">l</span>) <span class="id">Int64.half_modulus</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">des_sumbool</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int64.half_modulus_power</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">two_power_pos_correct</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Z.pow_pos_fold</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">etrans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Z.pow_lt_mono_r</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">T0</span>: <span class="id">Int64.unsigned</span> <span class="id">l</span> &lt;= <span class="id">Z.pow_pos</span> 2 53).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int64.half_modulus_power</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">two_power_pos_correct</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Z.lt_le_incl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Z.pow_pos_fold</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">etrans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Z.pow_le_mono_r</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">T1</span>: <span class="id">Z.abs</span> (<span class="id">Int64.signed</span> <span class="id">l</span>) &lt;= <span class="id">Z.pow_pos</span> 2 53).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Z.abs</span>, <span class="id">Int64.signed</span>. <span class="id">des_ifs</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">Zlt_neg_0</span> <span class="id">p</span>); <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">Int64.unsigned_range</span> <span class="id">l</span>); <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>. <span class="tactic">do</span> 2 <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Float.of_longu_of_long_1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.ltu</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="id">ss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.ltu</span> <span class="id">l</span> (<span class="id">Int64.repr</span> <span class="id">Int64.half_modulus</span>)) <span class="id">eqn</span>:<span class="id">T</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dup</span> <span class="id">T</span>; <span class="tactic">unfold</span> <span class="id">Int64.ltu</span> <span class="kwd">in</span> <span class="id">T</span>; <span class="id">des_ifs</span>; <span class="tactic">do</span> 2 <span class="tactic">f_equal</span>; <span class="id">clear_tac</span>.<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">Z.pow_pos</span> 2 53 &lt;= <span class="id">Int64.unsigned</span> <span class="id">l</span>) <span class="tactic">by</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">T</span>: 2 ^ 36 &lt;= (<span class="id">Int64.unsigned</span> <span class="id">l</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Z.pow_pos_fold</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">etrans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Z.pow_le_mono_r</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">T1</span>: <span class="id">Z.pow_pos</span> 2 36 &lt;= <span class="id">Z.abs</span> (<span class="id">Int64.signed</span> <span class="id">l</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="id">etrans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.signed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Float.of_longu_of_long_1</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{ <span class="tactic">rename</span> <span class="id">g0</span> <span class="id">into</span> <span class="id">G</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.addfs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.floatoflong</span>, <span class="id">round_to_odd</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">Val.shrlu</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Z.ge_le</span> <span class="kwd">in</span> <span class="id">G</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int64.half_modulus_power</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">two_power_pos_correct</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">P0</span>: <span class="id">Z.pow_pos</span> 2 36 &lt;= <span class="id">Int64.unsigned</span> <span class="id">l</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">etrans</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Val.orl</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rename</span> <span class="id">i</span> <span class="id">into</span> <span class="id">rto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">P1</span>: <span class="id">Z.pow_pos</span> 2 36 &lt;= (<span class="id">Z.abs</span> (<span class="id">Int64.signed</span> (<span class="id">Int64.or</span> (<span class="id">Int64.shru</span>' <span class="id">l</span> <span class="id">Int.one</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Int64.and</span> <span class="id">l</span> <span class="id">Int64.one</span>))))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">clear</span> - <span class="id">G</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">Z.pow_pos</span> 2 36 &lt;= (<span class="id">Int64.signed</span> (<span class="id">Int64.or</span> (<span class="id">Int64.shru</span>' <span class="id">l</span> <span class="id">Int.one</span>) (<span class="id">Int64.and</span> <span class="id">l</span> <span class="id">Int64.one</span>))));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int64.signed_eq_unsigned</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.max_signed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">Int64.unsigned</span> (<span class="id">Int64.or</span> (<span class="id">Int64.shru</span>' <span class="id">l</span> <span class="id">Int.one</span>) (<span class="id">Int64.and</span> <span class="id">l</span> <span class="id">Int64.one</span>)) &lt; <span class="id">Int64.half_modulus</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int64.half_modulus_power</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">Z.max</span> (<span class="id">Int64.size</span> (<span class="id">Int64.shru</span>' <span class="id">l</span> <span class="id">Int.one</span>)) (<span class="id">Int64.size</span> (<span class="id">Int64.and</span> <span class="id">l</span> <span class="id">Int64.one</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= (<span class="id">Int64.zwordsize</span> - 1)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>((<span class="id">Int64.size</span> (<span class="id">Int64.shru</span>' <span class="id">l</span> <span class="id">Int.one</span>)) &lt;= 63).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">Int64.bits_size_3</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">Int64.zwordsize</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">i</span> = 63) <span class="tactic">by</span> <span class="id">lia</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int64.bits_shru</span>'; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>((<span class="id">Int64.size</span> (<span class="id">Int64.and</span> <span class="id">l</span> <span class="id">Int64.one</span>)) &lt;= 63).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">etrans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Int64.size_and</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">etrans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Z.le_min_r</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> (<span class="id">Int64.or_interval</span> (<span class="id">Int64.shru</span>' <span class="id">l</span> <span class="id">Int.one</span>) (<span class="id">Int64.and</span> <span class="id">l</span> <span class="id">Int64.one</span>)); <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">P</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Z.lt_le_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">two_p_monotone</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">etrans</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Z.le_max_r</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Int64.size_range</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">etrans</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Int64.or_le</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int64.unsigned_repr</span> <span class="kwd">in</span> *; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">Int64.testbit</span> <span class="id">l</span> 63 = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">Int64.sign_bit_of_unsigned</span>. <span class="id">des_ifs</span>. <span class="tactic">rewrite</span> <span class="id">Int64.half_modulus_power</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">two_power_pos_correct</span> <span class="kwd">in</span> *. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">Int64.testbit</span> (<span class="id">Int64.shru</span>' <span class="id">l</span> <span class="id">Int.one</span>) 62 = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">Int64.bits_shru</span>'; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> (<span class="id">Int64.bits_le</span> (<span class="id">Int64.repr</span> (2 ^ 62)) (<span class="id">Int64.shru</span>' <span class="id">l</span> <span class="id">Int.one</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">Z.shiftr</span> <span class="id">Z.testbit</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int64.testbit_repr</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">by</span> <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zeq</span> <span class="id">i</span> 62); <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">Z.pow2_bits_false</span> <span class="kwd">in</span> *; <span class="id">ss</span>. <span class="id">lia</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">P</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">etrans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int64.unsigned_repr</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Float.of_longu_of_long_2</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Float.mul2_add</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">Val.shrlu</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.orl</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;}<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Program</span> <span class="kwd">Definition</span> <span class="id">mp</span>: <span class="id">ModPair.t</span> :=<br/>
&nbsp;&nbsp;<span class="id">ModPair.mk</span> <span class="id">DemoSpec.module</span> <span class="id">DemoTarget.md</span> (<span class="id">SimSymbId.mk</span> <span class="id">DemoSpec.module</span> <span class="id">DemoTarget.md</span>).<br/>
<br/>
<span class="kwd">Program</span> <span class="kwd">Definition</span> <span class="id">nat_idx</span> (<span class="id">n</span>: <span class="id">nat</span>): <span class="id">Ord.idx</span> := @<span class="id">Ord.mk</span> <span class="id">nat</span> <span class="id">Nat.lt</span> <span class="id">_</span> <span class="id">_</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nat_S_ord</span> <span class="id">n</span>:<br/>
&nbsp;&nbsp;<span class="id">Ord.ord</span> (<span class="id">nat_idx</span> <span class="id">n</span>) (<span class="id">nat_idx</span> (<span class="id">S</span> <span class="id">n</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6331')">Proof.</div>
<div class="proofscript" id="proof6331">
 <span class="tactic">eapply</span> <span class="id">Ord.lift_idx_spec</span>. <span class="id">ss</span>. Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">nat_S_ord</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">E0_double</span>:<br/>
&nbsp;&nbsp;<span class="id">E0</span> = <span class="id">E0</span> ** <span class="id">E0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6332')">Proof.</div>
<div class="proofscript" id="proof6332">
 <span class="tactic">auto</span>. Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">E0_double</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">StoreArguments</span> <span class="id">StoreArgumentsProps</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">correct</span><br/>
&nbsp;&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ModPair.sim</span> <span class="id">mp</span><br/>
.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6333')">Proof.</div>
<div class="proofscript" id="proof6333">
&nbsp;&nbsp;<span class="id">econs</span>; <span class="tactic">eauto</span>; <span class="id">ss</span>. <span class="id">i</span>. <span class="id">inv</span> <span class="id">SSLE</span>.<br/>
&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;{ <span class="id">i</span>. <span class="tactic">eapply</span> <span class="id">SoundTop.sound_state_local_preservation</span>. }<br/>
&nbsp;&nbsp;{ <span class="id">i</span>. <span class="tactic">eapply</span> <span class="id">Preservation.local_preservation_noguarantee_weak</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">SoundTop.sound_state_local_preservation</span>. }<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">FPTRTGT</span>: <span class="id">Genv.find_funct</span> (<span class="id">SkEnv.revive</span> (<span class="id">SkEnv.project</span> <span class="id">skenv_link_tgt</span> (<span class="id">Sk.of_program</span> <span class="id">fn_sig</span> <span class="id">DemoTarget.prog</span>)) <span class="id">DemoTarget.prog</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Args.get_fptr</span> <span class="id">args_tgt</span>) = <span class="id">Some</span> (<span class="id">AST.Internal</span> (<span class="id">DemoTarget.func</span>))).<br/>
&nbsp;&nbsp;{  <span class="tactic">clear</span> - <span class="id">INCLTGT</span> <span class="id">FINDFTGT</span> <span class="id">WFTGT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.find_funct</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Genv.find_funct_ptr_iff</span> <span class="kwd">in</span> <span class="id">FINDFTGT</span>. <span class="tactic">apply</span> <span class="id">Genv.find_funct_ptr_iff</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">SkEnv.revive</span>. <span class="id">exploit</span> <span class="id">SkEnv.project_impl_spec</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Genv_map_defs_def_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">o_bind</span>, <span class="id">o_join</span>, <span class="id">o_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.invert_symbol</span> <span class="id">skenv_link_tgt</span> <span class="id">b</span>) <span class="id">eqn</span>:<span class="id">SEQ</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exploit</span> <span class="id">DEFORPHAN</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">des</span>. <span class="id">clarify</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">DEFKEPT</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">des</span>. <span class="tactic">apply</span> <span class="id">prog_defmap_image</span> <span class="kwd">in</span> <span class="id">PROG</span>. <span class="id">ss</span>. <span class="id">des</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Genv.invert_find_symbol</span> <span class="kwd">in</span> <span class="id">SEQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Genv.find_invert_symbol</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">erewrite</span> <span class="id">SYMBKEEP</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span> <span class="id">INVSYMB</span>. <span class="tactic">rewrite</span> <span class="id">INVSYMB</span>. <span class="id">ss</span>. }<br/>
<br/>
&nbsp;&nbsp;<span class="id">esplits</span>; <span class="id">ss</span>; <span class="id">i</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;{ <span class="id">des</span>. <span class="id">inv</span> <span class="id">SAFESRC</span>. <span class="id">clarify</span>. <span class="id">inv</span> <span class="id">SIMARGS</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">asm_initial_frame_succeed</span>; <span class="tactic">eauto</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">inject_list_length</span> <span class="kwd">in</span> <span class="id">VALS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">VS</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="id">ss</span>. }<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ARGLONG</span>: <span class="id">exists</span> <span class="id">lng</span>, (<span class="id">Args.vs</span> <span class="id">args_src</span>) = [<span class="id">Vlong</span> <span class="id">lng</span>]).<br/>
&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">SAFESRC</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">VS</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">INITTGT</span>; <span class="id">ss</span>; <span class="id">clarify</span>. <span class="id">inv</span> <span class="id">TYP</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">SIMARGS</span>; <span class="id">ss</span>. <span class="id">clarify</span>. <span class="id">inv</span> <span class="id">VALS</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;<span class="id">ss</span>. <span class="id">clarify</span>. <span class="tactic">unfold</span> <span class="id">AsmC.store_arguments</span> <span class="kwd">in</span> *. <span class="id">des</span>.<br/>
&nbsp;&nbsp;<span class="id">dup</span> <span class="id">STORE0</span>. <span class="id">inv</span> <span class="id">STORE0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">typify_list</span>, <span class="id">zip</span> <span class="kwd">in</span> *. <span class="id">inv</span> <span class="id">VALS</span>. <span class="id">des_ifs_safe</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Conventions1.loc_arguments</span>, <span class="id">Conventions1.size_arguments</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H3</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="id">eexists</span> (<span class="id">DemoSpec.mkstate</span> <span class="id">lng</span> (<span class="id">SimMemInj.src</span> <span class="id">sm_arg</span>)). <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">refl</span>.<br/>
&nbsp;&nbsp;- <span class="id">ss</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">Genv.find_funct</span> <span class="kwd">in</span> <span class="id">FINDF</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1:=<span class="id">nat_idx</span> 10).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Val.floatoflongu</span> (<span class="id">typify</span> (<span class="id">Vlong</span> <span class="id">lng</span>) <span class="id">AST.Tlong</span>)) <span class="id">eqn</span>:<span class="id">VEQ</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">instantiate</span> (1:=<span class="id">unit</span>). <span class="tactic">unfold</span> <span class="id">lxsim</span>. <span class="id">pfold</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">_</span>. <span class="id">econs</span> 1. <span class="id">ii</span>. <span class="id">econs</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">split</span>; <span class="id">ii</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H2</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">VEQ</span> <span class="id">SPEC</span>. <span class="tactic">unfold</span> <span class="id">typify</span> <span class="kwd">in</span> *. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>. <span class="id">inv</span> <span class="id">STEPSRC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">econs</span>; <span class="id">ii</span>; <span class="id">ss</span>. }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dup</span> <span class="id">VEQ</span>. <span class="tactic">unfold</span> <span class="id">typify</span>, <span class="id">to_mregset</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.floatoflongu</span> <span class="kwd">in</span> <span class="id">VEQ0</span>. <span class="id">des_ifs</span>; <span class="id">inv</span> <span class="id">H</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rename</span> <span class="id">H</span> <span class="id">into</span> <span class="id">RDIV</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Z.mul_0_r</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.free</span> (<span class="id">JunkBlock.assign_junk_blocks</span> <span class="id">m0</span> <span class="id">n</span>) (<span class="id">Mem.nextblock</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm_arg</span>)) 0 0) <span class="kwd">as</span> [<span class="id">m</span>|] <span class="id">eqn</span>:<span class="id">MEQ</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exfalso</span>. <span class="id">hexploit</span> <span class="id">Mem.range_perm_free</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>. <span class="id">exfalso</span>. <span class="id">instantiate</span> (1:=0) <span class="kwd">in</span> <span class="id">H</span>. <span class="id">instantiate</span> (1:=0) <span class="kwd">in</span> <span class="id">H</span>. <span class="id">nia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">intros</span> [<span class="id">m</span> <span class="id">FREE</span>]. <span class="tactic">rewrite</span> <span class="id">MEQ</span> <span class="kwd">in</span> *. <span class="id">clarify</span>. }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> <span class="id">sm1</span>, ((&lt;&lt;<span class="id">MWF</span>: <span class="id">SimMemInj.wf</span>' <span class="id">sm1</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">MLE</span>: <span class="id">SimMemInj.le</span>' <span class="id">sm_arg</span> <span class="id">sm1</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">MEMSRC</span>: <span class="id">SimMemInj.src</span> <span class="id">sm1</span> = <span class="id">SimMemInj.src</span> <span class="id">sm_arg</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">MEMTGT</span>: <span class="id">SimMemInj.tgt</span> <span class="id">sm1</span> = <span class="id">m</span>&gt;&gt;))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">UNCH0</span>: <span class="id">Mem.unchanged_on</span> <span class="id">top2</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm_arg</span>) <span class="id">m</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">etrans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">store_arguments_unchanged_on</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">etrans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">JunkBlock.assign_junk_blocks_unchanged_on</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.free_unchanged_on</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dup</span> <span class="id">UNCH0</span>. <span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_nextblock</span> <span class="kwd">in</span> <span class="id">UNCH0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">SimMemInjC.update</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sm_arg</span> (<span class="id">SimMemInj.src</span> <span class="id">sm_arg</span>) <span class="id">m</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_arg</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">SimMemInjC.update</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">MWF</span>. <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">MemoryC.private_unchanged_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">etrans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">SimMemInj.tgt_private</span>. <span class="id">ss</span>. <span class="id">ii</span>. <span class="id">des</span>. <span class="tactic">split</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">SimMemInj.valid_blocks</span>, <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">etrans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">esplits</span>; <span class="tactic">eauto</span>. <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">refl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_implies</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>. <span class="id">ii</span>. <span class="id">des</span>. <span class="id">clarify</span>. + <span class="id">econs</span>. <span class="id">ii</span>. <span class="id">des</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_unchanged_on_2</span>; <span class="tactic">eauto</span>. } <span class="id">des</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">NEXT0</span>: (<span class="id">compare_longs</span> (<span class="id">Val.andl</span> (<span class="id">rs</span> <span class="id">RDI</span>) (<span class="id">rs</span> <span class="id">RDI</span>)) (<span class="id">Vlong</span> <span class="id">Int64.zero</span>) <span class="id">rs</span> (<span class="id">JunkBlock.assign_junk_blocks</span> <span class="id">m0</span> <span class="id">n</span>)) <span class="id">PC</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id">Vptr</span> <span class="id">b</span> <span class="id">Ptrofs.zero</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">compare_longs</span>, <span class="id">Pregmap.set</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">RDI0</span>: (<span class="id">compare_longs</span> (<span class="id">Val.andl</span> (<span class="id">rs</span> <span class="id">RDI</span>) (<span class="id">rs</span> <span class="id">RDI</span>)) (<span class="id">Vlong</span> <span class="id">Int64.zero</span>) <span class="id">rs</span> (<span class="id">JunkBlock.assign_junk_blocks</span> <span class="id">m0</span> <span class="id">n</span>)) <span class="id">RDI</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id">Vlong</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">compare_longs</span>, <span class="id">Pregmap.set</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SF0</span>: (<span class="id">compare_longs</span> (<span class="id">Val.andl</span> (<span class="id">rs</span> <span class="id">RDI</span>) (<span class="id">rs</span> <span class="id">RDI</span>)) (<span class="id">Vlong</span> <span class="id">Int64.zero</span>) <span class="id">rs</span> (<span class="id">JunkBlock.assign_junk_blocks</span> <span class="id">m0</span> <span class="id">n</span>)) <span class="id">SF</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="kwd">if</span> (<span class="id">Int64.lt</span> <span class="id">i</span> <span class="id">Int64.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> (<span class="id">Vint</span> <span class="id">Int.one</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> (<span class="id">Vint</span> <span class="id">Int.zero</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">compare_longs</span>, <span class="id">Pregmap.set</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">RDIV</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.negative</span>. <span class="tactic">rewrite</span> <span class="id">Int64.and_idem</span>. <span class="tactic">rewrite</span> <span class="id">Int64.sub_zero_l</span>. <span class="id">des_ifs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">RA0</span>: (<span class="id">compare_longs</span> (<span class="id">Val.andl</span> (<span class="id">rs</span> <span class="id">RDI</span>) (<span class="id">rs</span> <span class="id">RDI</span>)) (<span class="id">Vlong</span> <span class="id">Int64.zero</span>) <span class="id">rs</span> (<span class="id">JunkBlock.assign_junk_blocks</span> <span class="id">m0</span> <span class="id">n</span>)) <span class="id">RA</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id">rs</span> <span class="id">RA</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">compare_longs</span>, <span class="id">Pregmap.set</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">compare_longs</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pfold</span>. <span class="id">econs</span> 1. <span class="tactic">intros</span> <span class="id">_</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.lt</span> <span class="id">i</span> <span class="id">Int64.zero</span>) <span class="id">eqn</span>:<span class="id">CASE</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span> 2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">split</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="tactic">eauto</span>; [<span class="id">econs</span>;[<span class="tactic">eapply</span> <span class="id">modsem_determinate</span>; <span class="tactic">eauto</span>|]; <span class="id">instantiate</span> (1:= <span class="id">mkstate</span> <span class="id">_</span> <span class="id">_</span>); <span class="id">econs</span>; <span class="id">ss</span>; <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>; [<span class="id">des_ifs</span>| ..];<span class="id">ss</span>|];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>, <span class="id">undef_regs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> ((<span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span> <span class="tactic">by</span> <span class="id">clarify</span>));(<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>)); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RDI0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">SF0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RA0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">NEXT0</span>); <span class="id">des_ifs</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">do</span> 9 (<span class="id">econs</span> 2; <span class="tactic">eauto</span>; [<span class="id">econs</span>;[<span class="tactic">eapply</span> <span class="id">modsem_determinate</span>; <span class="tactic">eauto</span>|]; <span class="id">instantiate</span> (1:= <span class="id">mkstate</span> <span class="id">_</span> <span class="id">_</span>); <span class="id">econs</span>; <span class="id">ss</span>; <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>; [<span class="id">des_ifs</span>| ..];<span class="id">ss</span>|];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>, <span class="id">undef_regs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> ((<span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span> <span class="tactic">by</span> <span class="id">clarify</span>));(<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>)); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RDI0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">SF0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RA0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">NEXT0</span>); <span class="id">des_ifs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span> 1; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">left</span>. <span class="id">pfold</span>. <span class="id">econs</span> 4; <span class="id">cycle</span> 2; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="tactic">rewrite</span> <span class="id">Heq</span>. <span class="id">ss</span>. <span class="id">des_ifs</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>, <span class="id">undef_regs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> ((<span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span> <span class="tactic">by</span> <span class="id">clarify</span>));(<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>)); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RDI0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">SF0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RA0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">NEXT0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">external_state</span>. <span class="id">des_ifs</span>. <span class="id">exfalso</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.find_funct</span>, <span class="id">Genv.find_funct_ptr</span> <span class="kwd">in</span> <span class="id">Heq2</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.genv_defs_range</span> <span class="kwd">in</span> <span class="id">Heq3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">RANOTFPTR</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="tactic">destruct</span> (<span class="id">Genv.find_funct</span> <span class="id">skenv_link_tgt</span> (<span class="id">rs</span> <span class="id">RA</span>)) <span class="id">eqn</span>:<span class="id">FINDRA</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.find_funct</span>, <span class="id">Genv.find_funct_ptr</span> <span class="kwd">in</span> <span class="id">FINDRA</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exfalso</span>. <span class="tactic">eapply</span> <span class="id">Genv.genv_defs_range</span> <span class="kwd">in</span> <span class="id">Heq2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">RANOTFPTR</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Conventions1.is_callee_save</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>; <span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>, <span class="id">undef_regs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> ((<span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span> <span class="tactic">by</span> <span class="id">clarify</span>));(<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>)); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RDI0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">SF0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RA0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">NEXT0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="tactic">unfold</span> <span class="id">Conventions1.size_arguments</span>. <span class="id">des_ifs</span>. <span class="id">ss</span>. <span class="id">zsimpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="tactic">unfold</span> <span class="id">Conventions1.loc_result</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id">instantiate</span> (1:= <span class="id">sm1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>, <span class="id">undef_regs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> ((<span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span> <span class="tactic">by</span> <span class="id">clarify</span>));(<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>)); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RDI0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">SF0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RA0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">NEXT0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rpapply</span> <span class="id">Val.inject_float</span>. <span class="tactic">clear</span> - <span class="id">CASE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.lt</span>, <span class="id">Int64.signed</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">Int64.unsigned_zero</span> <span class="kwd">in</span> *. <span class="tactic">set</span> (<span class="id">Int64.unsigned_range_2</span> <span class="id">i</span>). <span class="id">nia</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">Float.mul2_add</span>. <span class="tactic">rewrite</span> <span class="id">Float.of_longu_of_long_2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.ltu</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id">refl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span> 2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">split</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="tactic">eauto</span>; [<span class="id">econs</span>;[<span class="tactic">eapply</span> <span class="id">modsem_determinate</span>; <span class="tactic">eauto</span>|]; <span class="id">instantiate</span> (1:= <span class="id">mkstate</span> <span class="id">_</span> <span class="id">_</span>); <span class="id">econs</span>; <span class="id">ss</span>; <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>; [<span class="id">des_ifs</span>| ..];<span class="id">ss</span>|];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>, <span class="id">undef_regs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> ((<span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span> <span class="tactic">by</span> <span class="id">clarify</span>));(<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>)); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RDI0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">SF0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RA0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">NEXT0</span>); <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">do</span> 4 (<span class="id">econs</span> 2; <span class="tactic">eauto</span>; [<span class="id">econs</span>;[<span class="tactic">eapply</span> <span class="id">modsem_determinate</span>; <span class="tactic">eauto</span>|]; <span class="id">instantiate</span> (1:= <span class="id">mkstate</span> <span class="id">_</span> <span class="id">_</span>); <span class="id">econs</span>; <span class="id">ss</span>; <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>; [<span class="id">des_ifs</span>| ..];<span class="id">ss</span>|];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>, <span class="id">undef_regs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> ((<span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span> <span class="tactic">by</span> <span class="id">clarify</span>));(<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>)); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RDI0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">SF0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RA0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">NEXT0</span>); <span class="id">des_ifs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span> 1; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">left</span>. <span class="id">pfold</span>. <span class="id">econs</span> 4; <span class="id">cycle</span> 2; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="tactic">rewrite</span> <span class="id">Heq</span>. <span class="id">ss</span>. <span class="id">des_ifs</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>, <span class="id">undef_regs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> ((<span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span> <span class="tactic">by</span> <span class="id">clarify</span>));(<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>)); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RDI0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">SF0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RA0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">NEXT0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">external_state</span>. <span class="id">des_ifs</span>. <span class="id">exfalso</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.find_funct</span>, <span class="id">Genv.find_funct_ptr</span> <span class="kwd">in</span> <span class="id">Heq2</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.genv_defs_range</span> <span class="kwd">in</span> <span class="id">Heq3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">RANOTFPTR</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="tactic">destruct</span> (<span class="id">Genv.find_funct</span> <span class="id">skenv_link_tgt</span> (<span class="id">rs</span> <span class="id">RA</span>)) <span class="id">eqn</span>:<span class="id">FINDRA</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.find_funct</span>, <span class="id">Genv.find_funct_ptr</span> <span class="kwd">in</span> <span class="id">FINDRA</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exfalso</span>. <span class="tactic">eapply</span> <span class="id">Genv.genv_defs_range</span> <span class="kwd">in</span> <span class="id">Heq2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">RANOTFPTR</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Conventions1.is_callee_save</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>; <span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>, <span class="id">undef_regs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> ((<span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span> <span class="tactic">by</span> <span class="id">clarify</span>));(<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>)); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RDI0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">SF0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RA0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">NEXT0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="tactic">unfold</span> <span class="id">Conventions1.size_arguments</span>. <span class="id">des_ifs</span>. <span class="id">ss</span>. <span class="id">zsimpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="tactic">unfold</span> <span class="id">Conventions1.loc_result</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id">instantiate</span> (1:= <span class="id">sm1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>, <span class="id">undef_regs</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> ((<span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span> <span class="tactic">by</span> <span class="id">clarify</span>));(<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>)); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RDI0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">SF0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">RA0</span>); (<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">NEXT0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rpapply</span> <span class="id">Val.inject_float</span>. <span class="tactic">clear</span> - <span class="id">CASE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">f_equal</span>. <span class="tactic">rewrite</span> <span class="id">Float.of_longu_of_long_1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">Int64.unsigned_range</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.ltu</span>, <span class="id">Int64.lt</span>, <span class="id">Int64.signed</span> <span class="kwd">in</span> *. <span class="id">zsimpl</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int64.unsigned_zero</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> <span class="id">Int64.unsigned_repr</span> <span class="kwd">in</span> *; <span class="id">nia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id">refl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="tactic">eauto</span>.<br/>
Qed.</div>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</div>
</body>
</html>
