
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module AsmgenproofC</title>
<meta name="description" content="Documentation of Coq module AsmgenproofC" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module AsmgenproofC</h1>
<div class="coq">
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">CoqlibC</span> <span class="id">Errors</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Integers</span> <span class="id">Floats</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ValuesC</span> <span class="id">Memory</span> <span class="id">Events</span> <span class="id">Globalenvs</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Op</span> <span class="id">Locations</span> <span class="id">MachC</span> <span class="id">Conventions</span> <span class="id">ConventionsC</span> <span class="id">AsmC</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Asmgen</span> <span class="id">Asmgenproof0</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">sflib</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Export</span> <span class="id">Asmgenproof</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">SimModSem</span> <span class="id">SimMemExt</span> <span class="id">SimSymbId</span> <span class="id">MemoryC</span> <span class="id">ValuesC</span> <span class="id">MemdataC</span> <span class="id">LocationsC</span> <span class="id">StoreArguments</span> <span class="id">Conventions1C</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Skeleton</span> <span class="id">Mod</span> <span class="id">ModSem</span> <span class="id">SimMod</span> <span class="id">SimSymb</span> <span class="id">SimMem</span> <span class="id">AsmregsC</span> <span class="id">MatchSimModSem</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">JunkBlock</span> <span class="id">StoreArgumentsProps</span>.<br/>
<span class="kwd">Require</span> <span class="id">SoundTop</span>.<br/>
<br/>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">Z.mul</span>.<br/>
<span class="kwd">Local</span> <span class="id">Existing</span> <span class="kwd">Instance</span> <span class="id">main_args_some</span>.<br/>
<br/>
<span class="kwd">Set</span> <span class="kwd">Implicit</span> <span class="id">Arguments</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">PRESERVATION</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">skenv_link</span>: <span class="id">SkEnv.t</span>.<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">Mach.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">Asm.program</span>.<br/>
<span class="kwd">Let</span> <span class="id">md_src</span>: <span class="id">Mod.t</span> := (<span class="id">MachC.module</span> <span class="id">prog</span> <span class="id">return_address_offset</span>).<br/>
<span class="kwd">Let</span> <span class="id">md_tgt</span>: <span class="id">Mod.t</span> := (<span class="id">AsmC.module</span> <span class="id">tprog</span>).<br/>
<span class="kwd">Hypothesis</span> (<span class="id">INCLSRC</span>: <span class="id">SkEnv.includes</span> <span class="id">skenv_link</span> <span class="id">md_src</span>.(<span class="id">Mod.sk</span>)).<br/>
<span class="kwd">Hypothesis</span> (<span class="id">INCLTGT</span>: <span class="id">SkEnv.includes</span> <span class="id">skenv_link</span> <span class="id">md_tgt</span>.(<span class="id">Mod.sk</span>)).<br/>
<span class="kwd">Hypothesis</span> (<span class="id">WF</span>: <span class="id">SkEnv.wf</span> <span class="id">skenv_link</span>).<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := (<span class="id">SkEnv.revive</span> (<span class="id">SkEnv.project</span> <span class="id">skenv_link</span> <span class="id">md_src</span>.(<span class="id">Mod.sk</span>)) <span class="id">prog</span>).<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := (<span class="id">SkEnv.revive</span> (<span class="id">SkEnv.project</span> <span class="id">skenv_link</span> <span class="id">md_tgt</span>.(<span class="id">Mod.sk</span>)) <span class="id">tprog</span>).<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">sm_link</span>: <span class="id">SimMem.t</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">msp</span>: <span class="id">ModSemPair.t</span> :=<br/>
&nbsp;&nbsp;<span class="id">ModSemPair.mk</span> (<span class="id">SM</span> := <span class="id">SimMemExt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">md_src</span>.(<span class="id">Mod.modsem</span>) <span class="id">skenv_link</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">md_tgt</span>.(<span class="id">Mod.modsem</span>) <span class="id">skenv_link</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SimSymbId.mk</span> <span class="id">md_src</span> <span class="id">md_tgt</span>) <span class="id">sm_link</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">get_rs</span> (<span class="id">ms</span>: <span class="id">Mach.state</span>) : <span class="id">Mach.regset</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ms</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Mach.State</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">rs</span> <span class="id">_</span> =&gt; <span class="id">rs</span><br/>
&nbsp;&nbsp;| <span class="id">Callstate</span> <span class="id">_</span> <span class="id">_</span> <span class="id">rs</span> <span class="id">_</span> =&gt; <span class="id">rs</span><br/>
&nbsp;&nbsp;| <span class="id">Returnstate</span> <span class="id">_</span> <span class="id">rs</span> <span class="id">_</span> =&gt; <span class="id">rs</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Record</span> <span class="id">agree_eq</span> (<span class="id">ms</span>: <span class="id">Mach.regset</span>) (<span class="id">sp</span>: <span class="id">val</span>) (<span class="id">rs</span>: <span class="id">Asm.regset</span>) (<span class="id">sg</span>: <span class="id">signature</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">mkagree</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">agree_sp</span>: <span class="id">rs</span>#<span class="id">SP</span> = <span class="id">sp</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">agree_sp_def</span>: <span class="id">sp</span> &lt;&gt; <span class="id">Vundef</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">agree_mregs_less</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">r</span>: <span class="id">mreg</span>) (<span class="id">IN</span>: <span class="id">In</span> (<span class="id">R</span> <span class="id">r</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>))),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Val.lessdef</span> (<span class="id">ms</span> <span class="id">r</span>) (<span class="id">rs</span>#(<span class="id">preg_of</span> <span class="id">r</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">agree_mregs_eq</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">r</span>: <span class="id">mreg</span>) (<span class="id">NOTIN</span>: ~ <span class="id">In</span> (<span class="id">R</span> <span class="id">r</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>))),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ms</span> <span class="id">r</span>) = (<span class="id">rs</span>#(<span class="id">preg_of</span> <span class="id">r</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">set_regset</span> (<span class="id">rs0</span> <span class="id">rs1</span>: <span class="id">Mach.regset</span>) (<span class="id">sg</span>: <span class="id">signature</span>) (<span class="id">mr</span>: <span class="id">mreg</span>) : <span class="id">val</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">Loc.notin_dec</span> (<span class="id">R</span> <span class="id">mr</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)) <span class="kwd">then</span> <span class="id">rs1</span> <span class="id">mr</span> <span class="kwd">else</span> <span class="id">rs0</span> <span class="id">mr</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">set_regset_undef</span> (<span class="id">rs</span>: <span class="id">Mach.regset</span>) (<span class="id">sg</span>: <span class="id">signature</span>) (<span class="id">mr</span>: <span class="id">mreg</span>) : <span class="id">val</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">Loc.notin_dec</span> (<span class="id">R</span> <span class="id">mr</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)) <span class="kwd">then</span> <span class="id">Vundef</span> <span class="kwd">else</span> <span class="id">rs</span> <span class="id">mr</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_init_data</span> <span class="id">init_sp</span> <span class="id">init_ra</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">init_rs_src</span> <span class="id">init_sg_src</span> <span class="id">init_rs_tgt</span> : <span class="kwd">Prop</span> :=<br/>
| <span class="id">match_init_data_intro</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INITRA</span>: <span class="id">init_ra</span> = <span class="id">init_rs_tgt</span> <span class="id">RA</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INITRAPTR</span>: &lt;&lt;<span class="id">TPTR</span>: <span class="id">Val.has_type</span> (<span class="id">init_ra</span>) <span class="id">Tptr</span>&gt;&gt; /\ &lt;&lt;<span class="id">RADEF</span>: <span class="id">init_ra</span> &lt;&gt; <span class="id">Vundef</span>&gt;&gt;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INITRS</span>: <span class="id">agree_eq</span> <span class="id">init_rs_src</span> <span class="id">init_sp</span> <span class="id">init_rs_tgt</span> <span class="id">init_sg_src</span> )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SIG</span>: <span class="id">exists</span> <span class="id">fd</span>, <span class="id">tge</span>.(<span class="id">Genv.find_funct</span>) (<span class="id">init_rs_tgt</span> <span class="id">PC</span>) = <span class="id">Some</span> (<span class="id">Internal</span> <span class="id">fd</span>) /\ <span class="id">fd</span>.(<span class="id">fn_sig</span>) = <span class="id">init_sg_src</span> /\ <span class="id">init_sg_src</span>.(<span class="id">sig_cstyle</span>)).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">stack_base</span> (<span class="id">initial_parent_sp</span> <span class="id">initial_parent_ra</span>: <span class="id">val</span>): <span class="id">list</span> <span class="id">Mach.stackframe</span> -&gt; <span class="kwd">Prop</span> :=<br/>
| <span class="id">stack_base_dummy</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack_base</span> <span class="id">initial_parent_sp</span> <span class="id">initial_parent_ra</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">dummy_stack</span> <span class="id">initial_parent_sp</span> <span class="id">initial_parent_ra</span>)::[])<br/>
| <span class="id">stack_base_cons</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fr</span> <span class="id">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TL</span>: <span class="id">stack_base</span> <span class="id">initial_parent_sp</span> <span class="id">initial_parent_ra</span> <span class="id">ls</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack_base</span> <span class="id">initial_parent_sp</span> <span class="id">initial_parent_ra</span> (<span class="id">fr</span>::<span class="id">ls</span>).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">idx</span>: <span class="id">nat</span>) (<span class="id">st_src0</span>: <span class="id">MachC.state</span>) (<span class="id">st_tgt0</span>: <span class="id">AsmC.state</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sm0</span>: <span class="id">SimMem.t</span>): <span class="kwd">Prop</span> :=<br/>
| <span class="id">match_states_intro</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">init_sp</span> <span class="id">init_ra</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initial_parent_ra_ptr</span>: <span class="id">Val.has_type</span> <span class="id">init_ra</span> <span class="id">Tptr</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initial_parent_ra_def</span>: <span class="id">init_ra</span> &lt;&gt; <span class="id">Vundef</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initial_parent_ra_junk</span>: <span class="kwd">forall</span> <span class="id">blk</span> <span class="id">ofs</span> (<span class="id">RAVAL</span>: <span class="id">init_ra</span> = <span class="id">Vptr</span> <span class="id">blk</span> <span class="id">ofs</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ <span class="id">Plt</span> <span class="id">blk</span> (<span class="id">Genv.genv_next</span> <span class="id">skenv_link</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKWF</span>: <span class="id">stack_base</span> <span class="id">init_sp</span> <span class="id">init_ra</span> (<span class="id">get_stack</span> <span class="id">st_src0</span>.(<span class="id">MachC.st</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INITDATA</span>: <span class="id">match_init_data</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">init_sp</span> <span class="id">init_ra</span> <span class="id">st_src0</span>.(<span class="id">MachC.init_rs</span>) <span class="id">st_src0</span>.(<span class="id">init_sg</span>) <span class="id">st_tgt0</span>.(<span class="id">init_rs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MATCHST</span>: <span class="id">Asmgenproof.match_states</span> <span class="id">ge</span> <span class="id">st_src0</span>.(<span class="id">MachC.st</span>) <span class="id">st_tgt0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCOMPATSRC</span>: <span class="id">st_src0</span>.(<span class="id">MachC.st</span>).(<span class="id">MachC.get_mem</span>) = <span class="id">sm0</span>.(<span class="id">SimMem.src</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCOMPATTGT</span>: <span class="id">st_tgt0</span>.(<span class="id">get_mem</span>) = <span class="id">sm0</span>.(<span class="id">SimMem.tgt</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">IDX</span>: <span class="kwd">measure</span> <span class="id">st_src0</span>.(<span class="id">MachC.st</span>) = <span class="id">idx</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">asm_step_dstep</span> <span class="id">init_rs</span> <span class="id">st0</span> <span class="id">st1</span> <span class="id">tr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STEP</span>: <span class="id">Asm.step</span> <span class="id">skenv_link</span> <span class="id">tge</span> <span class="id">st0</span> <span class="id">tr</span> <span class="id">st1</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Simulation.DStep</span> (<span class="id">modsem</span> <span class="id">skenv_link</span> <span class="id">tprog</span>) (<span class="id">mkstate</span> <span class="id">init_rs</span> <span class="id">st0</span>) <span class="id">tr</span> (<span class="id">mkstate</span> <span class="id">init_rs</span> <span class="id">st1</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6957')">Proof.</div>
<div class="proofscript" id="proof6957">
&nbsp;&nbsp;<span class="id">econs</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">modsem_determinate</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;- <span class="id">econs</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">asm_star_dstar</span> <span class="id">init_rs</span> <span class="id">st0</span> <span class="id">st1</span> <span class="id">tr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STEP</span>: <span class="id">star</span> <span class="id">Asm.step</span> <span class="id">skenv_link</span> <span class="id">tge</span> <span class="id">st0</span> <span class="id">tr</span> <span class="id">st1</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Simulation.DStar</span> (<span class="id">modsem</span> <span class="id">skenv_link</span> <span class="id">tprog</span>) (<span class="id">mkstate</span> <span class="id">init_rs</span> <span class="id">st0</span>) <span class="id">tr</span> (<span class="id">mkstate</span> <span class="id">init_rs</span> <span class="id">st1</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6958')">Proof.</div>
<div class="proofscript" id="proof6958">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">STEP</span>; <span class="id">econs</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">asm_step_dstep</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">asm_plus_dplus</span> <span class="id">init_rs</span> <span class="id">st0</span> <span class="id">st1</span> <span class="id">tr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STEP</span>: <span class="id">plus</span> <span class="id">Asm.step</span> <span class="id">skenv_link</span> <span class="id">tge</span> <span class="id">st0</span> <span class="id">tr</span> <span class="id">st1</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Simulation.DPlus</span> (<span class="id">modsem</span> <span class="id">skenv_link</span> <span class="id">tprog</span>) (<span class="id">mkstate</span> <span class="id">init_rs</span> <span class="id">st0</span>) <span class="id">tr</span> (<span class="id">mkstate</span> <span class="id">init_rs</span> <span class="id">st1</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6959')">Proof.</div>
<div class="proofscript" id="proof6959">
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STEP</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">asm_step_dstep</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">asm_star_dstar</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">make_match_genvs</span> :<br/>
&nbsp;&nbsp;<span class="id">SimSymbId.sim_skenv</span> (<span class="id">SkEnv.project</span> <span class="id">skenv_link</span> <span class="id">md_src</span>.(<span class="id">Mod.sk</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SkEnv.project</span> <span class="id">skenv_link</span> <span class="id">md_tgt</span>.(<span class="id">Mod.sk</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.match_genvs</span> (<span class="id">match_globdef</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>) <span class="id">eq</span> <span class="id">prog</span>) <span class="id">ge</span> <span class="id">tge</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6960')">Proof.</div>
<div class="proofscript" id="proof6960">
 <span class="id">subst_locals</span>. <span class="tactic">eapply</span> <span class="id">SimSymbId.sim_skenv_revive</span>; <span class="tactic">eauto</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_function_sig</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fd_src</span> <span class="id">fd_tgt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRANS</span>: <span class="id">transf_function</span> <span class="id">fd_src</span> = <span class="id">OK</span> <span class="id">fd_tgt</span>):<br/>
&nbsp;&nbsp;<span class="id">fd_src</span>.(<span class="id">Mach.fn_sig</span>) = <span class="id">fd_tgt</span>.(<span class="id">fn_sig</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6961')">Proof.</div>
<div class="proofscript" id="proof6961">
 <span class="tactic">repeat</span> <span class="tactic">unfold</span> <span class="id">transf_function</span>, <span class="id">bind</span>, <span class="id">transl_function</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>. Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">sim_modsem</span>: <span class="id">ModSemPair.sim</span> <span class="id">msp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6962')">Proof.</div>
<div class="proofscript" id="proof6962">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_sim</span> <span class="kwd">with</span> (<span class="id">match_states</span> := <span class="id">match_states</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">match_states_at</span> := <span class="id">top4</span>); <span class="tactic">eauto</span>; <span class="id">ii</span>; <span class="id">ss</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="tactic">apply</span> <span class="id">lt_wf</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">SoundTop.sound_state_local_preservation</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">INITTGT</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="id">des_safe</span>. <span class="id">inv</span> <span class="id">SAFESRC</span>. <span class="id">inv</span> <span class="id">SIMARGS</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>. <span class="id">inv</span> <span class="id">SAFESRC</span>. <span class="tactic">destruct</span> <span class="id">sm_arg</span>, <span class="id">args_src</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">SIMARGS</span>; <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">make_match_genvs</span>; <span class="tactic">eauto</span>. { <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. } <span class="tactic">intro</span> <span class="id">SIMGE</span>. <span class="id">des</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SRCSTORE</span>: <span class="id">exists</span> <span class="id">rs_src</span> <span class="id">m_src</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">StoreArguments.store_arguments</span> <span class="id">src</span> <span class="id">rs_src</span> (<span class="id">typify_list</span> <span class="id">vs_src</span> (<span class="id">sig_args</span> (<span class="id">fn_sig</span> <span class="id">fd</span>))) (<span class="id">fn_sig</span> <span class="id">fd</span>) <span class="id">m_src</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">agree_eq</span> <span class="id">rs_src</span> (<span class="id">Vptr</span> (<span class="id">Mem.nextblock</span> <span class="id">src</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Ptrofs.zero</span>) <span class="id">rs</span> (<span class="id">fn_sig</span> <span class="id">fd</span>) /\ <span class="id">Mem.extends</span> <span class="id">m_src</span> <span class="id">m0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">TYP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">store_arguments_parallel_extends</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">typify_has_type_list</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">SkEnv.revive_incl_skenv</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">INCLTGT</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">des</span>. <span class="id">inv</span> <span class="id">WF</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">WFPARAM</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">instantiate</span> (1:= <span class="id">typify_list</span> <span class="id">vs_src</span> (<span class="id">sig_args</span> (<span class="id">fn_sig</span> <span class="id">fd</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">lessdef_list_typify_list</span>; <span class="tactic">eauto</span>. <span class="id">erewrite</span> <span class="id">lessdef_list_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">MWF</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">STORE</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">i</span>. <span class="id">des</span>. <span class="id">exists</span> (<span class="id">set_regset</span> <span class="id">rs_src</span> (<span class="id">to_mregset</span> <span class="id">rs</span>) (<span class="id">fn_sig</span> <span class="id">fd</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">clear</span> - <span class="id">ARGTGT</span>. <span class="id">inv</span> <span class="id">ARGTGT</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">extcall_arguments_same</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">set_regset</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Loc.notin_not_in</span> <span class="kwd">in</span> <span class="id">n</span>. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">STORE</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">inv</span> <span class="id">MWF</span>. <span class="tactic">rewrite</span> <span class="id">mext_next</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">intros</span> <span class="id">X</span>. <span class="id">inv</span> <span class="id">X</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">set_regset</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">val_inject_id</span>. <span class="tactic">eapply</span> <span class="id">AGREE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">set_regset</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LocationsC.Loc_not_in_notin_R</span> <span class="kwd">in</span> <span class="id">NOTIN</span>. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SRCSTORE</span> <span class="kwd">as</span> [<span class="id">rs_src</span> [<span class="id">m_src</span> [<span class="id">SRCSTORE</span> [<span class="id">AGREE</span> <span class="id">EXTENDS</span>]]]]. <span class="id">inv</span> <span class="id">AGREE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">MachC.mkstate</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rs_src</span> (<span class="id">fn_sig</span> <span class="id">fd</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Callstate</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">dummy_stack</span> (<span class="id">Vptr</span> (<span class="id">Mem.nextblock</span> <span class="id">src</span>) <span class="id">Ptrofs.zero</span>) (<span class="id">rs</span> <span class="id">RA</span>)]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fptr_src</span> <span class="id">rs_src</span> (<span class="id">assign_junk_blocks</span> <span class="id">m_src</span> <span class="id">n</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">FPTR</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="tactic">auto</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">TYP0</span>. <span class="id">clear_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">SIG2</span>: <span class="id">fn_sig</span> <span class="id">fd</span> = (<span class="id">Mach.fn_sig</span> <span class="id">fd0</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">hexploit</span> (<span class="id">Genv.find_funct_transf_partial_genv</span> <span class="id">SIMGE</span>); <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">folder</span>. <span class="id">ss</span>; <span class="tactic">try</span> <span class="tactic">unfold</span> <span class="id">bind</span> <span class="kwd">in</span> *; <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">transf_function_sig</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="tactic">eauto</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">econs</span>; <span class="tactic">eauto</span>; <span class="id">ss</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">ii</span>. <span class="id">erewrite</span> (<span class="id">agree_mregs_eq0</span> <span class="id">mr</span>) <span class="kwd">in</span> *; <span class="tactic">auto</span>. <span class="tactic">unfold</span> <span class="id">NW</span>. <span class="tactic">apply</span> <span class="id">NNPP</span>. <span class="tactic">intro</span> <span class="id">T</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">PTRFREE</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">instantiate</span> (1:= <span class="id">preg_of</span> <span class="id">mr</span>). <span class="tactic">intro</span> <span class="id">U</span>. <span class="id">contradict</span> <span class="id">T</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_junk_value</span> <span class="kwd">in</span> <span class="id">U</span>. <span class="tactic">unfold</span> <span class="id">is_junk_value</span>. <span class="id">des_ifs</span>. <span class="id">des</span>. <span class="tactic">split</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">erewrite</span> <span class="id">Mem.valid_block_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">erewrite</span> <span class="id">Mem.valid_block_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">assign_junk_block_extends</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="id">des</span>; <span class="tactic">try</span> (<span class="tactic">by</span> <span class="tactic">destruct</span> <span class="id">mr</span>; <span class="id">clarify</span>). <span class="tactic">rewrite</span> <span class="id">Asm.to_preg_to_mreg</span> <span class="kwd">in</span> *. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">instantiate</span> (1:= <span class="id">SimMemExt.mk</span> (<span class="id">assign_junk_blocks</span> <span class="id">m_src</span> <span class="id">n</span>) (<span class="id">assign_junk_blocks</span> <span class="id">m0</span> <span class="id">n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">RADEF</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">econs</span>; <span class="tactic">eauto</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="tactic">by</span> (<span class="id">econs</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">assign_junk_block_extends</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="tactic">eauto</span>. <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">In</span> (<span class="id">R</span> <span class="id">r</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> (<span class="id">fn_sig</span> <span class="id">fd</span>))))); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">agree_mregs_eq0</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="id">ss</span>. <span class="id">des</span>. <span class="id">inv</span> <span class="id">SAFESRC</span>. <span class="id">inv</span> <span class="id">SIMARGS</span>; <span class="id">ss</span>. <span class="tactic">destruct</span> <span class="id">sm_arg</span>; <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">make_match_genvs</span>; <span class="tactic">eauto</span>. { <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. } <span class="tactic">intro</span> <span class="id">SIMGE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> (<span class="id">Genv.find_funct_transf_partial_genv</span> <span class="id">SIMGE</span>); <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">ss</span>; <span class="tactic">unfold</span> <span class="id">bind</span> <span class="kwd">in</span> *; <span class="id">des_ifs</span>. <span class="tactic">rename</span> <span class="id">f</span> <span class="id">into</span> <span class="id">fd_tgt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TYP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">SIG</span>: <span class="id">fn_sig</span> <span class="id">fd_tgt</span> = (<span class="id">Mach.fn_sig</span> <span class="id">fd</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">hexploit</span> (<span class="id">Genv.find_funct_transf_partial_genv</span> <span class="id">SIMGE</span>); <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">folder</span>. <span class="id">ss</span>; <span class="tactic">try</span> <span class="tactic">unfold</span> <span class="id">bind</span> <span class="kwd">in</span> *; <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">transf_function_sig</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> <span class="id">rs_tgt</span> <span class="id">m_tgt</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">STORE</span>: <span class="id">AsmC.store_arguments</span> <span class="id">tgt</span> <span class="id">rs_tgt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">typify_list</span> <span class="id">vs_tgt</span> (<span class="id">sig_args</span> (<span class="id">Mach.fn_sig</span> <span class="id">fd</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;(Args.vs&nbsp;args_tgt)&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mach.fn_sig</span> <span class="id">fd</span>) <span class="id">m_tgt</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">RSPC</span>: <span class="id">rs_tgt</span> <span class="id">PC</span> = <span class="id">fptr_tgt</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">RSRA</span>: <span class="id">rs_tgt</span> <span class="id">RA</span> = <span class="id">Vnullptr</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">PTRFREE</span>: <span class="kwd">forall</span> <span class="id">pr</span> (<span class="id">PTR</span>: ~ <span class="id">is_junk_value</span> <span class="id">m0</span> (<span class="id">assign_junk_blocks</span> <span class="id">m0</span> <span class="id">n</span>) (<span class="id">rs_tgt</span> <span class="id">pr</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">INARG</span>: <span class="id">exists</span> <span class="id">mr</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">MR</span>: <span class="id">to_mreg</span> <span class="id">pr</span> = <span class="id">Some</span> <span class="id">mr</span>&gt;&gt;) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">ARG</span>: <span class="id">In</span> (<span class="id">R</span> <span class="id">mr</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> (<span class="id">Mach.fn_sig</span> <span class="id">fd</span>)))&gt;&gt;)&gt;&gt;) \/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">INPC</span>: <span class="id">pr</span> = <span class="id">PC</span>&gt;&gt;) \/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">INRSP</span>: <span class="id">pr</span> = <span class="id">RSP</span>&gt;&gt;)&gt;&gt;)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exploit</span> <span class="id">StoreArgumentsProps.store_arguments_progress</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">instantiate</span> (2:=<span class="id">typify_list</span> <span class="id">vs_tgt</span> (<span class="id">sig_args</span> (<span class="id">Mach.fn_sig</span> <span class="id">fd</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">typify_has_type_list</span>. <span class="id">erewrite</span> &lt;- <span class="id">lessdef_list_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">SkEnv.revive_incl_skenv</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">INCLTGT</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">des</span>. <span class="id">inv</span> <span class="id">WF</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">WFPARAM</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">eauto</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">SIG</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">instantiate</span> (1:= <span class="id">n</span>). <span class="id">i</span>. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> ((<span class="id">to_pregset</span> (<span class="id">set_regset_undef</span> <span class="id">rs0</span> (<span class="id">Mach.fn_sig</span> <span class="id">fd</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<span class="id">PC</span> &lt;- <span class="id">fptr_tgt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<span class="id">RA</span> &lt;- <span class="id">Vnullptr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<span class="id">RSP</span> &lt;- (<span class="id">Vptr</span> (<span class="id">Mem.nextblock</span> <span class="id">tgt</span>) <span class="id">Ptrofs.zero</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">split</span>; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">STR</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">extcall_arguments_same</span>; <span class="tactic">eauto</span>. <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">assert</span> (<span class="id">NNIN</span>: ~ <span class="id">Loc.notin</span> (<span class="id">R</span> <span class="id">r</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> (<span class="id">Mach.fn_sig</span> <span class="id">fd</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">intros</span> <span class="id">X</span>. <span class="tactic">eapply</span> <span class="id">Loc.notin_not_in</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">set_regset_undef</span>, <span class="id">to_pregset</span>, <span class="id">to_mregset</span>, <span class="id">Pregmap.set</span>, <span class="id">to_preg</span>, <span class="id">preg_of</span>, <span class="id">to_mreg</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">eauto</span>; <span class="id">des_ifs</span>; <span class="tactic">try</span> <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">NNIN</span>: <span class="kwd">forall</span> <span class="id">mr</span>, ~ <span class="id">Loc.notin</span> (<span class="id">R</span> <span class="id">mr</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> (<span class="id">Mach.fn_sig</span> <span class="id">fd</span>))) -&gt; <span class="id">In</span> (<span class="id">R</span> <span class="id">mr</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> (<span class="id">Mach.fn_sig</span> <span class="id">fd</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">intros</span> <span class="id">mr</span> <span class="id">NIN</span>. <span class="tactic">clear</span> - <span class="id">NIN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">NNPP</span>. <span class="tactic">intros</span> <span class="id">X</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">LocationsC.Loc_not_in_notin_R</span> <span class="kwd">in</span> <span class="id">X</span>. <span class="id">des</span>. <span class="id">contradiction</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">NNIN</span> <span class="id">PTR</span>. <span class="tactic">unfold</span> <span class="id">set_regset_undef</span>, <span class="id">to_pregset</span>, <span class="id">to_mregset</span>, <span class="id">Pregmap.set</span>, <span class="id">to_preg</span>, <span class="id">preg_of</span>, <span class="id">to_mreg</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">pr</span>; <span class="id">des_ifs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>. <span class="id">exfalso</span>. <span class="tactic">apply</span> <span class="id">PTR</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>. <span class="id">eexists</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>; <span class="id">swap</span> 1 2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">folder</span>. <span class="id">inv</span> <span class="id">FPTR</span>; <span class="id">ss</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">RSRA</span>. <span class="id">econs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">RSRA</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">SIG</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">LEN</span>. <span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">lessdef_list_length</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">erewrite</span> &lt;- <span class="id">transf_function_sig</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">erewrite</span> &lt;- <span class="id">transf_function_sig</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="id">hexploit</span> <span class="id">PTRFREE0</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">apply</span> <span class="id">PTR</span>. <span class="tactic">unfold</span> <span class="id">is_junk_value</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.valid_block</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">assign_junk_blocks_nextblock</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STORE</span>. <span class="id">inv</span> <span class="id">STORE0</span>. <span class="id">inv</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">NB0</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">NB</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> (<span class="id">Mem.nextblock_alloc</span> <span class="id">src</span>) <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MWF</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">mext_next</span>. <span class="id">des</span>; <span class="id">esplits</span>; <span class="tactic">eauto</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">MATCH</span>; <span class="id">ss</span>. <span class="tactic">destruct</span> <span class="id">st_src0</span>, <span class="id">st_tgt0</span>, <span class="id">sm0</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">MATCHST</span>; <span class="id">ss</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="id">ss</span>. <span class="id">inv</span> <span class="id">CALLSRC</span>. <span class="id">inv</span> <span class="id">MATCH</span>. <span class="id">inv</span> <span class="id">INITDATA</span>. <span class="id">inv</span> <span class="id">MATCHST</span>. <span class="id">ss</span>. <span class="tactic">destruct</span> <span class="id">st_tgt0</span>. <span class="id">ss</span>. <span class="id">clarify</span>. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">FPTR</span>; <span class="id">ss</span>. <span class="tactic">destruct</span> (<span class="id">rs0</span> <span class="id">PC</span>) <span class="id">eqn</span>:<span class="id">PCEQ</span>; <span class="id">ss</span>. <span class="id">des_ifs</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Asmgenproof0.extcall_arguments_match</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">TGRARGS</span>. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_parallel_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">TGTFREE</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">r</span> <span class="kwd">in</span> <span class="id">TRANSF</span>. <span class="id">r</span> <span class="kwd">in</span> <span class="id">TRANSF</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">SimSymbId.sim_skenv_revive</span> <span class="id">TRANSF</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">GE</span>. <span class="tactic">apply</span> (<span class="id">fsim_external_funct_id</span> <span class="id">GE</span>); <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id">inv</span> <span class="id">STACKWF</span>; [|<span class="id">inv</span> <span class="id">TL</span>]. <span class="id">inv</span> <span class="id">ATLR</span>; <span class="tactic">auto</span>; <span class="id">exfalso</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="tactic">destruct</span> <span class="id">ra</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">ATLR</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">inv</span> <span class="id">AG</span>. <span class="tactic">rewrite</span> <span class="id">agree_sp0</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">instantiate</span> (1:= <span class="id">SimMemExt.mk</span> <span class="id">m1</span> <span class="id">m2</span>'). <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ss</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">AFTERSRC</span>. <span class="id">ss</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="tactic">destruct</span> <span class="id">st_tgt0</span>, <span class="id">st</span>. <span class="id">inv</span> <span class="id">MATCH</span>. <span class="id">inv</span> <span class="id">MATCHST</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">INITDATA</span>. <span class="id">inv</span> <span class="id">SIMRET</span>; <span class="id">ss</span>. <span class="tactic">destruct</span> <span class="id">sm_ret</span>. <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem_unfree_parallel_extends</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">UNFREE</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">TGTUNFREE</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">exists</span> <span class="id">skd</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>. <span class="tactic">replace</span> (<span class="id">r</span> <span class="id">PC</span>) <span class="kwd">with</span> <span class="id">fptr</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">FPTR</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">inv</span> <span class="id">AG</span>. <span class="tactic">rewrite</span> <span class="id">agree_sp0</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">instantiate</span> (1:= <span class="id">SimMemExt.mk</span> <span class="id">m1</span> <span class="id">m2</span>'). <span class="id">inv</span> <span class="id">INITRS</span>. <span class="id">inv</span> <span class="id">AG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>; <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">loc_external_result</span>, <span class="id">regset_after_external</span>, <span class="id">Mach.regset_after_external</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_set_other</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">agree_set_pair</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">to_preg_to_mreg</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Conventions1.is_callee_save</span> <span class="id">r0</span>) <span class="id">eqn</span>:<span class="id">T</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="id">ss</span>. <span class="id">inv</span> <span class="id">FINALSRC</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="tactic">destruct</span> <span class="id">st_tgt0</span>, <span class="id">st</span>. <span class="id">inv</span> <span class="id">MATCH</span>. <span class="id">inv</span> <span class="id">MATCHST</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">INITDATA</span>. <span class="tactic">destruct</span> <span class="id">sm0</span>. <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACKWF</span>; [|<span class="id">inv</span> <span class="id">TL</span>]. <span class="id">inv</span> <span class="id">STACKS</span>; [|<span class="id">inv</span> <span class="id">H7</span>; <span class="id">ss</span>]. <span class="id">inv</span> <span class="id">INITRS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_parallel_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">TGTFREE</span>. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">replace</span> (<span class="id">r</span> <span class="id">PC</span>) <span class="kwd">with</span> (<span class="id">init_rs0</span> <span class="id">RA</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">clear</span> - <span class="id">initial_parent_ra_junk</span>. <span class="tactic">unfold</span> <span class="id">external_state</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">initial_parent_ra_junk</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.find_funct_ptr</span>, <span class="id">Genv.find_def</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.genv_defs_range</span> <span class="kwd">in</span> <span class="id">Heq1</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">ATPC</span>; <span class="tactic">auto</span>. <span class="id">exfalso</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">inv</span> <span class="id">ATPC</span>; <span class="tactic">auto</span>. <span class="id">exfalso</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">Genv.find_funct</span>, <span class="id">Genv.find_funct_ptr</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exfalso</span>. <span class="id">exploit</span> <span class="id">Genv.genv_defs_range</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">initial_parent_ra_junk</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">inv</span> <span class="id">AG</span>. <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Val.lessdef_trans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">erewrite</span> &lt;- <span class="id">agree_mregs_eq0</span>; <span class="tactic">auto</span>. <span class="id">ii</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">loc_args_callee_save_disjoint</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">inv</span> <span class="id">AG</span>. <span class="tactic">rewrite</span> <span class="id">agree_sp0</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="tactic">simpl</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">ss</span>. <span class="id">inv</span> <span class="id">AG</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">instantiate</span> (1:= <span class="id">SimMemExt.mk</span> <span class="id">_</span> <span class="id">_</span>). <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ss</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="id">left</span>; <span class="id">i</span>. <span class="id">ss</span>. <span class="id">esplits</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">MachC.modsem_receptive</span>; <span class="id">et</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">i</span>. <span class="id">inv</span> <span class="id">STEPSRC</span>. <span class="id">inv</span> <span class="id">MATCH</span>. <span class="tactic">set</span> (<span class="id">INITDATA0</span> := <span class="id">INITDATA</span>). <span class="id">inv</span> <span class="id">INITDATA0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">INITRAPTR</span>. <span class="id">inv</span> <span class="id">INITRS0</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">step_simulation</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">agree_sp_def0</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">make_match_genvs</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="id">des</span>; <span class="id">ss</span>; <span class="id">esplits</span>; <span class="tactic">auto</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">left</span>. <span class="id">instantiate</span> (1 := <span class="id">mkstate</span> <span class="id">st_tgt0</span>.(<span class="id">init_rs</span>) <span class="id">S2</span>'). <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">st_tgt0</span>. <span class="tactic">eapply</span> <span class="id">asm_plus_dplus</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">instantiate</span> (1 := <span class="id">SimMemExt.mk</span> (<span class="id">MachC.get_mem</span> (<span class="id">MachC.st</span> <span class="id">st_src1</span>)) (<span class="id">get_mem</span> <span class="id">S2</span>')).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">instantiate</span> (1:=<span class="id">init_rs</span> <span class="id">st_tgt0</span> <span class="id">RSP</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">st_src0</span>, <span class="id">st_src1</span>. <span class="tactic">clear</span> - <span class="id">STEP</span> <span class="id">STACKWF</span> <span class="id">NOTDUMMY</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STEP</span>; <span class="id">ss</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">econs</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">STACKWF</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">INITRS</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">INITFPTR</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">right</span>. <span class="tactic">split</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">instantiate</span> (1 := <span class="id">SimMemExt.mk</span> (<span class="id">MachC.get_mem</span> (<span class="id">MachC.st</span> <span class="id">st_src1</span>)) <span class="id">st_tgt0</span>.(<span class="id">st</span>).(<span class="id">get_mem</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">instantiate</span> (1:=<span class="id">init_rs</span> <span class="id">st_tgt0</span> <span class="id">RSP</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">st_src0</span>, <span class="id">st_src1</span>. <span class="tactic">clear</span> - <span class="id">STEP</span> <span class="id">STACKWF</span> <span class="id">NOTDUMMY</span>. <span class="id">inv</span> <span class="id">STEP</span>; <span class="id">ss</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">econs</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">STACKWF</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">INITRS</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">INITFPTR</span>. <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="id">Unshelve</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">all</span>: <span class="id">ss</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PRESERVATION</span>.<br/>
<br/>
<br/>
<br/>
<span class="kwd">Section</span> <span class="id">SIMMOD</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">Mach.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSL</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<span class="kwd">Definition</span> <span class="id">mp</span>: <span class="id">ModPair.t</span> := <span class="id">mk_mp</span> (<span class="id">MachC.module</span> <span class="id">prog</span> <span class="id">return_address_offset</span>) (<span class="id">AsmC.module</span> <span class="id">tprog</span>).<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">sim_mod</span>: <span class="id">ModPair.sim</span> <span class="id">mp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6963')">Proof.</div>
<div class="proofscript" id="proof6963">
&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;- <span class="id">r</span>. <span class="tactic">eapply</span> <span class="id">Sk.match_program_eq</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="tactic">destruct</span> <span class="id">f1</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">clarify</span>. <span class="id">right</span>. <span class="tactic">unfold</span> <span class="id">bind</span> <span class="kwd">in</span> <span class="id">MATCH</span>. <span class="id">des_ifs</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transf_function</span>, <span class="id">transl_function</span>, <span class="id">bind</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">clarify</span>. <span class="id">left</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">ii</span>. <span class="id">inv</span> <span class="id">SIMSKENVLINK</span>. <span class="tactic">eapply</span> <span class="id">sim_modsem</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SIMMOD</span>.<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</div>
</body>
</html>
