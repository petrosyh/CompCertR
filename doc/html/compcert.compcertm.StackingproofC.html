
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module StackingproofC</title>
<meta name="description" content="Documentation of Coq module StackingproofC" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module StackingproofC</h1>
<div class="coq">
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">CoqlibC</span> <span class="id">Errors</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">IntegersC</span> <span class="id">ASTC</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ValuesC</span> <span class="id">MemoryC</span> <span class="id">SeparationC</span> <span class="id">Events</span> <span class="id">GlobalenvsC</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">LTL</span> <span class="id">Op</span> <span class="id">LocationsC</span> <span class="id">LinearC</span> <span class="id">MachC</span> <span class="id">MachExtra</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Bounds</span> <span class="id">ConventionsC</span> <span class="id">StacklayoutC</span> <span class="id">LineartypingC</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Stacking</span>.<br/>
<br/>
<span class="kwd">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">string_scope</span>.<br/>
<span class="kwd">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">sep_scope</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Export</span> <span class="id">Stackingproof</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Simulation</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Skeleton</span> <span class="id">Mod</span> <span class="id">ModSem</span> <span class="id">SimMod</span> <span class="id">SimModSem</span> <span class="id">SimSymb</span> <span class="id">SimMemLift</span> <span class="id">AsmregsC</span> <span class="id">MatchSimModSemExcl</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Conventions1C</span>.<br/>
<span class="kwd">Require</span> <span class="id">SimMemInjC</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AxiomsC</span>.<br/>
<span class="kwd">Require</span> <span class="id">SoundTop</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">StoreArguments</span> <span class="id">StoreArgumentsProps</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ModSemProps</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">LiftDummy</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">JunkBlock</span>.<br/>
<br/>
<span class="kwd">Set</span> <span class="kwd">Implicit</span> <span class="id">Arguments</span>.<br/>
<br/>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">Z.add</span> <span class="id">Z.mul</span> <span class="id">Z.div</span>.<br/>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">sepconj</span>.<br/>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">function_bounds</span>.<br/>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">make_env</span>.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">sep_simpl_tac</span> :=<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">NW</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> (<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">sep_assoc</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">sep_pure</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">stack_contents_nil_left_false</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">assumption</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">stack_contents_nil_right_false</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">assumption</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [<span class="id">H</span>: <span class="id">_</span> |= <span class="id">pure</span> <span class="id">False</span> |- <span class="id">_</span>] =&gt; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [<span class="id">H</span>: <span class="id">_</span> |= <span class="id">_</span> ** <span class="id">pure</span> <span class="id">False</span> |- <span class="id">_</span>] =&gt; <span class="tactic">apply</span> <span class="id">sep_proj2</span> <span class="kwd">in</span> <span class="id">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [<span class="id">H</span>: <span class="id">_</span> |= <span class="id">_</span> ** <span class="id">pure</span> <span class="id">False</span> ** <span class="id">_</span> |- <span class="id">_</span>] =&gt; <span class="tactic">apply</span> <span class="id">sep_pick2</span> <span class="kwd">in</span> <span class="id">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">idtac</span>).<br/>
<br/>
<span class="kwd">Notation</span> "'<span class="id">stack_contents</span>'" := (<span class="id">stack_contents_args</span>) (<span class="id">only</span> <span class="id">parsing</span>).<br/>
<br/>
<span class="kwd">Section</span> <span class="id">STACKINGEXTRA</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_stacks_sp_valid</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">se</span> <span class="id">tse</span> <span class="id">ge</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span> <span class="id">sm0</span> <span class="id">sp</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STKS</span>: <span class="id">match_stacks</span> <span class="id">se</span> <span class="id">tse</span> <span class="id">ge</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span> <span class="id">sm0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SP</span>: <span class="id">parent_sp</span> <span class="id">cs</span>' = <span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>):<br/>
&nbsp;&nbsp;&lt;&lt;<span class="id">SPVALID</span>: <span class="id">sm0</span>.(<span class="id">SimMemInj.tgt</span>).(<span class="id">Mem.valid_block</span>) <span class="id">sp</span>' /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">sm0</span>.(<span class="id">SimMemInj.tgt_parent_nb</span>) <span class="id">sp</span>' /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span>, ~ <span class="id">sm0</span>.(<span class="id">SimMemInj.tgt_external</span>) <span class="id">sp</span>' <span class="id">i</span>&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7410')">Proof.</div>
<div class="proofscript" id="proof7410">
 <span class="id">inv</span> <span class="id">STKS</span>; <span class="id">des_safe</span>; <span class="id">ss</span>; <span class="id">clarify</span>; <span class="id">inv</span> <span class="id">MAINARGS</span>; <span class="id">esplits</span>; <span class="tactic">eauto</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_stacks_sp_ofs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">se</span> <span class="id">tse</span> <span class="id">ge</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span> <span class="id">sm</span>,<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">se</span> <span class="id">tse</span> <span class="id">ge</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span> <span class="id">sm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">sp</span>, (<span class="id">parent_sp</span> <span class="id">cs</span>') = <span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7411')">Proof.</div>
<div class="proofscript" id="proof7411">
 <span class="tactic">induction</span> 1; <span class="id">ii</span>; <span class="id">ss</span>; <span class="id">esplits</span>; <span class="tactic">eauto</span>. Qed.</div>
<br/>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">Z.add</span> <span class="id">Z.mul</span> <span class="id">make_env</span> <span class="id">function_bounds</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">arguments_private</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sp_tgt</span> <span class="id">spdelta</span> <span class="id">m_src</span> <span class="id">m_tgt</span> <span class="id">stk_src</span> <span class="id">stk_tgt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">F</span> <span class="id">sg</span> <span class="id">se</span> <span class="id">tse</span> <span class="id">ge</span> <span class="id">sm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MATCH</span>: <span class="id">m_tgt</span> |= <span class="id">stack_contents</span> <span class="id">F</span> <span class="id">stk_src</span> <span class="id">stk_tgt</span> ** <span class="id">minjection</span> <span class="id">F</span> <span class="id">m_src</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">se</span> <span class="id">tse</span> <span class="id">ge</span> <span class="id">F</span> <span class="id">stk_src</span> <span class="id">stk_tgt</span> <span class="id">sg</span> <span class="id">sm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SP</span>: <span class="id">parent_sp</span> <span class="id">stk_tgt</span> = <span class="id">Vptr</span> <span class="id">sp_tgt</span> <span class="id">spdelta</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">_</span> : <span class="kwd">forall</span> <span class="id">ofs</span> (<span class="id">OFS</span>: 0 &lt;= <span class="id">ofs</span> &lt; 4 * <span class="id">size_arguments</span> <span class="id">sg</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">PRIV</span>: <span class="id">loc_out_of_reach</span> <span class="id">F</span> <span class="id">m_src</span> <span class="id">sp_tgt</span> (<span class="id">spdelta</span>.(<span class="id">Ptrofs.unsigned</span>) + <span class="id">ofs</span>)&gt;&gt;)&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7412')">Proof.</div>
<div class="proofscript" id="proof7412">
&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">separation_private</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">stk_tgt</span>; <span class="id">ss</span>. { <span class="id">inv</span> <span class="id">STACKS</span>. <span class="id">inv</span> <span class="id">MAINARGS</span>. } <span class="id">des_ifs</span>. <span class="tactic">destruct</span> <span class="id">stk_src</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;{ <span class="id">sep_simpl_tac</span>. <span class="id">des</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;<span class="id">des_ifs_safe</span>. <span class="id">des_ifs</span>; <span class="id">sep_simpl_tac</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">dummy_frame_contents</span> <span class="kwd">in</span> *. <span class="id">inv</span> <span class="id">MATCH</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">ss</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">STK</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">tailcall_size</span> <span class="kwd">in</span> <span class="id">LE</span>. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">clarify</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">sepconj</span>. <span class="id">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left</span>. <span class="id">left</span>. <span class="id">right</span>. <span class="id">left</span>. <span class="tactic">split</span>; [<span class="id">ss</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">MATCH</span>. <span class="tactic">unfold</span> <span class="id">frame_contents</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fe_ofs_arg</span>. <span class="tactic">rewrite</span> ! <span class="id">Z.add_0_l</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">ss</span>. <span class="id">des_ifs_safe</span>. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_zero</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="tactic">eauto</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">arguments_perm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">se</span> <span class="id">tse</span> <span class="id">ge</span> <span class="id">sm</span> <span class="id">sp_tgt</span> <span class="id">spdelta</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m_src</span> <span class="id">m_tgt</span> <span class="id">stk_src</span> <span class="id">stk_tgt</span> <span class="id">F</span> <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MATCH</span>: <span class="id">m_tgt</span> |= <span class="id">stack_contents</span> <span class="id">F</span> <span class="id">stk_src</span> <span class="id">stk_tgt</span> ** <span class="id">minjection</span> <span class="id">F</span> <span class="id">m_src</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">se</span> <span class="id">tse</span> <span class="id">ge</span> <span class="id">F</span> <span class="id">stk_src</span> <span class="id">stk_tgt</span> <span class="id">sg</span> <span class="id">sm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SP</span>: <span class="id">parent_sp</span> <span class="id">stk_tgt</span> = <span class="id">Vptr</span> <span class="id">sp_tgt</span> <span class="id">spdelta</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">_</span> : <span class="kwd">forall</span> <span class="id">ofs</span> (<span class="id">OFS</span>: 0 &lt;= <span class="id">ofs</span> &lt; 4 *<span class="id">size_arguments</span> <span class="id">sg</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">PERM</span>: <span class="id">Mem.perm</span> <span class="id">m_tgt</span> <span class="id">sp_tgt</span> (<span class="id">spdelta</span>.(<span class="id">Ptrofs.unsigned</span>) + <span class="id">ofs</span>) <span class="id">Cur</span> <span class="id">Freeable</span>&gt;&gt;)&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7413')">Proof.</div>
<div class="proofscript" id="proof7413">
&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">destruct</span> <span class="id">stk_tgt</span>; <span class="id">ss</span>. { <span class="id">inv</span> <span class="id">STACKS</span>. <span class="id">inv</span> <span class="id">MAINARGS</span>. } <span class="id">des_ifs</span>. <span class="tactic">destruct</span> <span class="id">stk_src</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;{ <span class="id">sep_simpl_tac</span>. <span class="id">des</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;<span class="id">des_ifs_safe</span>. <span class="id">des_ifs</span>; <span class="id">ss</span>; <span class="id">sep_simpl_tac</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">dummy_frame_contents</span> <span class="kwd">in</span> *. <span class="id">inv</span> <span class="id">MATCH</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">ss</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">STK</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">tailcall_size</span> <span class="kwd">in</span> <span class="id">LE</span>. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">clarify</span>. <span class="tactic">eapply</span> <span class="id">H4</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">MATCH</span>. <span class="tactic">unfold</span> <span class="id">frame_contents</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="id">des_ifs</span>. <span class="id">des</span>. <span class="tactic">apply</span> <span class="id">sep_pick2</span> <span class="kwd">in</span> <span class="id">MATCH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fe_ofs_arg</span> <span class="kwd">in</span> *. <span class="id">inv</span> <span class="id">MATCH</span>. <span class="id">des</span>; <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">H2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">ss</span>. <span class="tactic">rewrite</span> ! <span class="id">Z.add_0_l</span> <span class="kwd">in</span> *. <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_locations_range</span>: <span class="kwd">forall</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">k</span> <span class="id">rs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">massert_imp</span> (<span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">k</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">range</span> <span class="id">sp</span> <span class="id">lo</span> (<span class="id">lo</span> + (4 * <span class="id">hi</span>))).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7414')">Proof.</div>
<div class="proofscript" id="proof7414">
&nbsp;&nbsp;<span class="id">rr</span>. <span class="id">ss</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="id">i</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;<span class="id">i</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_cur</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_implies</span> <span class="kwd">with</span> (<span class="id">p1</span> := <span class="id">Freeable</span>); <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_locations_range_2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">slot</span> <span class="id">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SEP</span>: <span class="id">m</span> |= <span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">slot</span> <span class="id">ls</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">RANEG</span>: <span class="id">m</span> |= <span class="id">range</span> <span class="id">sp</span> <span class="id">pos</span> (<span class="id">pos</span> + 4 * <span class="id">bound</span>)&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7415')">Proof.</div>
<div class="proofscript" id="proof7415">
 <span class="id">ss</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_callee_save_regs_undef_outgoing_slots</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ls0</span> <span class="id">ls1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AG</span>: <span class="id">agree_callee_save_regs</span> <span class="id">ls0</span> <span class="id">ls1</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">AG</span>: <span class="id">agree_callee_save_regs</span> <span class="id">ls0</span> <span class="id">ls1</span>.(<span class="id">undef_outgoing_slots</span>)&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7416')">Proof.</div>
<div class="proofscript" id="proof7416">
 <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">undef_outgoing_slots</span>. <span class="tactic">apply</span> <span class="id">AG</span>; <span class="id">ss</span>. Qed.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Definition</span> <span class="id">freed_contains_locations</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">pos</span> <span class="id">bound</span>: <span class="id">Z</span>) (<span class="id">sl</span>: <span class="id">slot</span>) (<span class="id">ls</span>: <span class="id">locset</span>) : <span class="id">massert</span> := {|<br/>
&nbsp;&nbsp;<span class="id">m_pred</span> := <span class="kwd">fun</span> <span class="id">m</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(8 | <span class="id">pos</span>) /\ 0 &lt;= <span class="id">pos</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">sp</span>;<br/>
&nbsp;&nbsp;<span class="id">m_footprint</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">brange</span> <span class="id">sp</span> <span class="id">pos</span> (<span class="id">pos</span> + 4 * <span class="id">bound</span>)<br/>
|}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7417')">Next Obligation.</div>
<div class="proofscript" id="proof7417">
&nbsp;&nbsp;<span class="id">esplits</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_block_unchanged_on</span>; <span class="id">et</span>.<br/>
Qed.</div>
<div class="toggleproof" onclick="toggleDisplay('proof7418')">Next Obligation.</div>
<div class="proofscript" id="proof7418">
&nbsp;&nbsp;<span class="id">rr</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">des</span>. <span class="id">clarify</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Definition</span> <span class="id">contains_locations_tl</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">pos</span> <span class="id">from</span> <span class="id">bound</span>: <span class="id">Z</span>) (<span class="id">sl</span>: <span class="id">slot</span>) (<span class="id">ls</span>: <span class="id">locset</span>) : <span class="id">massert</span> := {|<br/>
&nbsp;&nbsp;<span class="id">m_pred</span> := <span class="kwd">fun</span> <span class="id">m</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">from</span> &lt;= <span class="id">bound</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pos</span> + 4 * <span class="id">bound</span> &lt;= <span class="id">Ptrofs.modulus</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">sp</span> (<span class="id">pos</span> + 4 * <span class="id">from</span>) (<span class="id">pos</span> + 4 * <span class="id">bound</span>) <span class="id">Cur</span> <span class="id">Freeable</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span>, <span class="id">from</span> &lt;= <span class="id">ofs</span> -&gt; <span class="id">ofs</span> + <span class="id">typesize</span> <span class="id">ty</span> &lt;= <span class="id">bound</span> -&gt; (<span class="id">Locations.typealign</span> <span class="id">ty</span> | <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>, <span class="id">Mem.load</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">m</span> <span class="id">sp</span> (<span class="id">pos</span> + 4 * <span class="id">ofs</span>) = <span class="id">Some</span> <span class="id">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>)) <span class="id">v</span>;<br/>
&nbsp;&nbsp;<span class="id">m_footprint</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">brange</span> <span class="id">sp</span> (<span class="id">pos</span> + 4 * <span class="id">from</span>) (<span class="id">pos</span> + 4 * <span class="id">bound</span>)<br/>
|}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7419')">Next Obligation.</div>
<div class="proofscript" id="proof7419">
&nbsp;&nbsp;<span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_unchanged_on</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">exploit</span> <span class="id">H3</span>; <span class="id">et</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_unchanged_on</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>; <span class="tactic">try</span> <span class="id">xomega</span>. <span class="tactic">rewrite</span> <span class="id">typesize_chunk</span> <span class="kwd">in</span> *. <span class="id">rr</span>. <span class="id">esplits</span>; <span class="id">et</span>; <span class="id">xomega</span>.<br/>
Qed.</div>
<div class="toggleproof" onclick="toggleDisplay('proof7420')">Next Obligation.</div>
<div class="proofscript" id="proof7420">
&nbsp;&nbsp;<span class="id">r</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="id">exploit</span> <span class="id">H2</span>; <span class="id">et</span>. <span class="id">i</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_valid_block</span>; <span class="id">et</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_locations_split</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">sl</span> <span class="id">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RANGE</span>: 0 &lt;= <span class="id">lo</span> &lt;= <span class="id">hi</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">massert_imp</span> (<span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">hi</span> <span class="id">sl</span> <span class="id">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">lo</span> <span class="id">sl</span> <span class="id">ls</span> ** <span class="id">contains_locations_tl</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">sl</span> <span class="id">ls</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7421')">Proof.</div>
<div class="proofscript" id="proof7421">
&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;unfold&nbsp;contains_locations.&nbsp;*)</span><br/>
&nbsp;&nbsp;- <span class="id">econs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">xomega</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">xomega</span> <span class="id">mem</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">xomega</span> <span class="id">mem</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">disjoint_footprint</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="id">ii</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="id">rr</span> <span class="kwd">in</span> <span class="id">H5</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="id">u</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">des</span>; <span class="id">clarify</span>; <span class="id">esplits</span>; <span class="id">et</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_locations_split_m_footprint</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">sl</span> <span class="id">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RANGE</span>: 0 &lt;= <span class="id">lo</span> &lt;= <span class="id">hi</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">hi</span> <span class="id">sl</span> <span class="id">ls</span>).(<span class="id">m_footprint</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= (<span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">lo</span> <span class="id">sl</span> <span class="id">ls</span> ** <span class="id">contains_locations_tl</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">sl</span> <span class="id">ls</span>).(<span class="id">m_footprint</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7422')">Proof.</div>
<div class="proofscript" id="proof7422">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">func_ext2</span>. <span class="id">i</span>. <span class="tactic">apply</span> <span class="id">prop_ext</span>. <span class="tactic">split</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;- <span class="id">ss</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">x1</span> &lt; <span class="id">pos</span> + 4 * <span class="id">lo</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">left</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">right</span>. <span class="id">rr</span>. <span class="tactic">split</span>; <span class="id">et</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">contains_locations_split</span>; <span class="id">et</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">free_freed_contains_locations</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">sz</span> <span class="id">sl</span> <span class="id">ls</span> <span class="id">m0</span> <span class="id">m1</span> <span class="id">CTX</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SEP</span>: <span class="id">m0</span> |= <span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">sz</span> <span class="id">sl</span> <span class="id">ls</span> ** <span class="id">CTX</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FREE</span>: <span class="id">Mem.free</span> <span class="id">m0</span> <span class="id">sp</span> <span class="id">pos</span> (<span class="id">pos</span> + 4 * <span class="id">sz</span>) = <span class="id">Some</span> <span class="id">m1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VALID</span>: <span class="id">Mem.valid_block</span> <span class="id">m0</span> <span class="id">sp</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">SEP</span>: <span class="id">m1</span> |= <span class="id">freed_contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">sz</span> <span class="id">sl</span> <span class="id">ls</span> ** <span class="id">CTX</span>&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7423')">Proof.</div>
<div class="proofscript" id="proof7423">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_isolated_mutation_revisited</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">Mem.free_unchanged_on</span>; <span class="id">et</span>. <span class="id">s</span>. <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">H0</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;- <span class="id">ss</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_block_free_1</span>; <span class="id">et</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">unfree_freed_contains_locations</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">sz</span> <span class="id">bound</span> <span class="id">ls</span> <span class="id">m0</span> <span class="id">m1</span> <span class="id">CTX</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SEP</span>: <span class="id">m0</span> |= <span class="id">freed_contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">sz</span> <span class="id">Outgoing</span> <span class="id">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">contains_locations_tl</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">sz</span> <span class="id">bound</span> <span class="id">Outgoing</span> <span class="id">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">CTX</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FREE</span>: <span class="id">Mem_unfree</span> <span class="id">m0</span> <span class="id">sp</span> <span class="id">pos</span> (<span class="id">pos</span> + 4 * <span class="id">sz</span>) = <span class="id">Some</span> <span class="id">m1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">BOUND</span>: <span class="id">sz</span> &lt;= <span class="id">bound</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">SEP</span>: <span class="id">m1</span> |= <span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">Outgoing</span> <span class="id">ls</span>.(<span class="id">undef_outgoing_slots</span>) ** <span class="id">CTX</span>&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7424')">Proof.</div>
<div class="proofscript" id="proof7424">
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">Mem_unfree_perm</span>; <span class="id">et</span>. <span class="tactic">intro</span> <span class="id">PERM</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem_unfree_unchanged_on</span>; <span class="id">et</span>. <span class="tactic">intro</span> <span class="id">UNCH</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_isolated_mutation_revisited</span> <span class="kwd">with</span> (<span class="id">CTX</span> := <span class="id">CTX</span>); <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">SEP</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;{ <span class="tactic">clear</span> <span class="id">SEP</span>. <span class="id">ss</span>. <span class="id">ii</span>. <span class="id">left</span>. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>. <span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">ofs</span> &lt; <span class="id">pos</span> + 4 * <span class="id">sz</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">PERM</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.perm_unchanged_on</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">u</span>. <span class="id">ii</span>. <span class="id">des</span>; <span class="id">clarify</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SEP5</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>. <span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">sz</span> &lt;= <span class="id">ofs</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">SEP6</span>; <span class="id">et</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_unchanged_on</span>; <span class="id">et</span>. <span class="id">u</span>. <span class="id">ii</span>. <span class="id">des</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">assert</span>(<span class="id">BDD</span>: <span class="id">ofs</span> &lt; <span class="id">sz</span>) <span class="tactic">by</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">LD</span>: <span class="id">exists</span> <span class="id">v</span>, <span class="id">Mem.load</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">m1</span> <span class="id">sp</span> (<span class="id">pos</span> + 4 * <span class="id">ofs</span>) = <span class="id">Some</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exploit</span> <span class="id">Mem.valid_access_load</span>; <span class="id">et</span>. <span class="id">rr</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Mem.range_perm_implies</span> <span class="kwd">with</span> (<span class="id">p1</span> := <span class="id">Freeable</span>); <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">ofs0</span> &lt; <span class="id">pos</span> + 4 * <span class="id">sz</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">PERM</span>; <span class="id">et</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.perm_unchanged_on</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">u</span>. <span class="id">ii</span>; <span class="id">des</span>. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SEP5</span>; <span class="id">et</span>. <span class="tactic">rewrite</span> <span class="id">typesize_chunk</span> <span class="kwd">in</span> *. <span class="tactic">split</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">align_type_chunk</span>. <span class="tactic">eapply</span> <span class="id">Z.divide_add_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">etrans</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">typealign_divide_8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">Z.mul_divide_mono_l</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="id">des</span>. <span class="id">ii</span>. <span class="id">des</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">x1</span> &lt; <span class="id">pos</span> + 4 * <span class="id">sz</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">left</span>. <span class="id">rr</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">right</span>. <span class="id">rr</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;}<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">frame_contents_1_at_external</span> <span class="id">f</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">ls</span> <span class="id">ls0</span>: <span class="id">locset</span>) (<span class="id">parent</span> <span class="id">retaddr</span>: <span class="id">val</span>) <span class="id">sg</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">b</span> := <span class="id">function_bounds</span> <span class="id">f</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">fe</span> := <span class="id">make_env</span> <span class="id">b</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">fe</span>.(<span class="id">fe_ofs_local</span>) <span class="id">b</span>.(<span class="id">bound_local</span>) <span class="kwd">Local</span> <span class="id">ls</span><br/>
&nbsp;** <span class="id">freed_contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">fe_ofs_arg</span> (<span class="id">size_arguments</span> <span class="id">sg</span>) <span class="id">Outgoing</span> <span class="id">ls</span><br/>
&nbsp;** <span class="id">contains_locations_tl</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">fe_ofs_arg</span> (<span class="id">size_arguments</span> <span class="id">sg</span>) (<span class="id">bound_outgoing</span> <span class="id">b</span>) <span class="id">Outgoing</span> <span class="id">ls</span><br/>
&nbsp;** <span class="id">hasvalue</span> <span class="id">Mptr</span> <span class="id">sp</span> <span class="id">fe</span>.(<span class="id">fe_ofs_link</span>) <span class="id">parent</span><br/>
&nbsp;** <span class="id">hasvalue</span> <span class="id">Mptr</span> <span class="id">sp</span> <span class="id">fe</span>.(<span class="id">fe_ofs_retaddr</span>) <span class="id">retaddr</span><br/>
&nbsp;** <span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">fe</span>.(<span class="id">fe_ofs_callee_save</span>) <span class="id">b</span>.(<span class="id">used_callee_save</span>) <span class="id">ls0</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">frame_contents_at_external</span> <span class="id">f</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">ls</span> <span class="id">ls0</span>: <span class="id">locset</span>) (<span class="id">parent</span> <span class="id">retaddr</span>: <span class="id">val</span>) <span class="id">sg</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">b</span> := <span class="id">function_bounds</span> <span class="id">f</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">fe</span> := <span class="id">make_env</span> <span class="id">b</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">mconj</span> (<span class="id">frame_contents_1_at_external</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">sg</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">freed_range</span> <span class="id">sp</span> <span class="id">fe_ofs_arg</span> (4 * (<span class="id">size_arguments</span> <span class="id">sg</span>)) **<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">range</span> <span class="id">sp</span> (4 * (<span class="id">size_arguments</span> <span class="id">sg</span>)) <span class="id">fe</span>.(<span class="id">fe_stack_data</span>)) **<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">range</span> <span class="id">sp</span> (<span class="id">fe</span>.(<span class="id">fe_stack_data</span>) + <span class="id">b</span>.(<span class="id">bound_stack_data</span>)) <span class="id">fe</span>.(<span class="id">fe_size</span>)).<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">stack_contents_at_external</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">cs</span>: <span class="id">list</span> <span class="id">Linear.stackframe</span>) (<span class="id">cs</span>': <span class="id">list</span> <span class="id">Mach.stackframe</span>) <span class="id">sg</span> : <span class="id">massert</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">cs</span>, <span class="id">cs</span>' <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [<span class="id">Linear.Stackframe</span> <span class="id">f</span> <span class="id">_</span> <span class="id">ls</span> <span class="id">_</span>], [<span class="id">Mach.Stackframe</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">spofs</span>) <span class="id">ra</span> <span class="id">_</span>] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">freed_range</span> <span class="id">sp</span>' <span class="id">spofs</span>.(<span class="id">Ptrofs.unsigned</span>) (4 * (<span class="id">size_arguments</span> <span class="id">sg</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">range</span> <span class="id">sp</span>' (4 * (<span class="id">size_arguments</span> <span class="id">sg</span>)) (4 * (<span class="id">size_arguments</span> <span class="id">f</span>.(<span class="id">Linear.fn_sig</span>)))<br/>
&nbsp;&nbsp;| <span class="id">Linear.Stackframe</span> <span class="id">f</span> <span class="id">_</span> <span class="id">ls</span> <span class="id">c</span> :: <span class="id">cs</span>, <span class="id">Mach.Stackframe</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">spofs</span>) <span class="id">ra</span> <span class="id">c</span>' :: <span class="id">cs</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">frame_contents_at_external</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span>' <span class="id">ls</span> (<span class="id">parent_locset</span> <span class="id">cs</span>) (<span class="id">parent_sp</span> <span class="id">cs</span>') (<span class="id">parent_ra</span> <span class="id">cs</span>') <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">stack_contents</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>'<br/>
&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">pure</span> <span class="id">False</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">stack_contents_at_external_footprint_split</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">f</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">c</span> <span class="id">fb</span> <span class="id">sp</span>' <span class="id">spofs</span> <span class="id">ra</span> <span class="id">c</span>' <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NONNIL</span>: <span class="id">cs</span> &lt;&gt; []):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m_footprint</span> (<span class="id">stack_contents_at_external</span> <span class="id">j</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">Linear.Stackframe</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">c</span>) :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">Mach.Stackframe</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">spofs</span>) <span class="id">ra</span> <span class="id">c</span>') :: <span class="id">cs</span>') <span class="id">sg</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">m_footprint</span> (<span class="id">frame_contents_at_external</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span>' <span class="id">ls</span> (<span class="id">parent_locset</span> <span class="id">cs</span>) (<span class="id">parent_sp</span> <span class="id">cs</span>') (<span class="id">parent_ra</span> <span class="id">cs</span>') <span class="id">sg</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\2/ <span class="id">m_footprint</span> (<span class="id">stack_contents</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>')).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7425')">Proof.</div>
<div class="proofscript" id="proof7425">
 <span class="id">ii</span>; <span class="id">ss</span>. <span class="id">des_ifs</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">stackframes_after_external_footprint</span>: <span class="kwd">forall</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stack_contents</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>').(<span class="id">m_footprint</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stack_contents</span> <span class="id">j</span> <span class="id">cs</span>.(<span class="id">stackframes_after_external</span>) <span class="id">cs</span>').(<span class="id">m_footprint</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7426')">Proof.</div>
<div class="proofscript" id="proof7426">
&nbsp;&nbsp;<span class="id">i</span>. <span class="tactic">apply</span> <span class="id">func_ext1</span>; <span class="id">i</span>. <span class="tactic">apply</span> <span class="id">func_ext1</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">prop_ext</span>. <span class="tactic">split</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="id">all</span>: <span class="tactic">destruct</span> <span class="id">cs</span>; <span class="id">ss</span>; <span class="id">des_ifs</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_contents_1_at_external_m_footprint</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">rs0</span> <span class="id">sp2</span> <span class="id">retaddr0</span> <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SZ</span>: 0 &lt;= <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">bound_outgoing</span> (<span class="id">function_bounds</span> <span class="id">f</span>)):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">frame_contents_1</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">rs0</span> <span class="id">sp2</span> <span class="id">retaddr0</span>).(<span class="id">m_footprint</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">frame_contents_1_at_external</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">rs0</span> <span class="id">sp2</span> <span class="id">retaddr0</span> <span class="id">sg</span>).(<span class="id">m_footprint</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7427')">Proof.</div>
<div class="proofscript" id="proof7427">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">func_ext2</span>. <span class="id">i</span>. <span class="tactic">apply</span> <span class="id">prop_ext</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;-&nbsp;ii.&nbsp;ss.&nbsp;des.&nbsp;esplits;&nbsp;eauto.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents_1</span>, <span class="id">frame_contents_1_at_external</span> <span class="kwd">in</span> *. <span class="tactic">split</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">swap</span> 2 3; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc_footprint</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span> := <span class="id">freed_contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">fe_ofs_arg</span> (<span class="id">size_arguments</span> <span class="id">sg</span>) <span class="id">Outgoing</span> <span class="id">rs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">swap</span> 2 3; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">contains_locations_split_m_footprint</span>; <span class="id">et</span>. <span class="id">refl</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">swap</span> 2 3; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc_footprint</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">P</span> := <span class="id">freed_contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">fe_ofs_arg</span> (<span class="id">size_arguments</span> <span class="id">sg</span>) <span class="id">Outgoing</span> <span class="id">rs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">swap</span> 2 3; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">contains_locations_split_m_footprint</span>; <span class="id">et</span>. <span class="id">refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_contents_at_external_m_footprint</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">rs0</span> <span class="id">sp2</span> <span class="id">retaddr0</span> <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SZ</span>: 0 &lt;= <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">bound_outgoing</span> (<span class="id">function_bounds</span> <span class="id">f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">BOUND</span>: 4 * <span class="id">bound_outgoing</span> (<span class="id">function_bounds</span> <span class="id">f</span>) &lt;= <span class="id">fe_stack_data</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>))):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">frame_contents</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">rs0</span> <span class="id">sp2</span> <span class="id">retaddr0</span>).(<span class="id">m_footprint</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">frame_contents_at_external</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">rs0</span> <span class="id">sp2</span> <span class="id">retaddr0</span> <span class="id">sg</span>).(<span class="id">m_footprint</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7428')">Proof.</div>
<div class="proofscript" id="proof7428">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents</span>, <span class="id">frame_contents_at_external</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fe_ofs_arg</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">frame_contents_1_at_external_m_footprint</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">func_ext2</span>. <span class="id">i</span>. <span class="tactic">apply</span> <span class="id">prop_ext</span>. <span class="tactic">split</span>; <span class="id">i</span>; <span class="id">des</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;- <span class="id">right</span>. <span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">H</span>; <span class="id">et</span>. <span class="tactic">clear</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="id">ii</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="tactic">destruct</span> (<span class="id">classic</span> (4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">x3</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">right</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">left</span>. <span class="id">rr</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;- <span class="id">right</span>. <span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">H</span>; <span class="id">et</span>. <span class="tactic">clear</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">brange</span> <span class="kwd">in</span> *. <span class="id">des</span>; <span class="id">clarify</span>; <span class="id">esplits</span>; <span class="id">et</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">stack_contents_at_external_m_footprint</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">se</span> <span class="id">tse</span> <span class="id">tge</span> <span class="id">sm0</span> <span class="id">stack</span> <span class="id">cs</span>' <span class="id">sg</span> <span class="id">j</span> <span class="id">F</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">se</span> <span class="id">tse</span> <span class="id">tge</span> <span class="id">F</span> <span class="id">stack</span> <span class="id">cs</span>' <span class="id">sg</span> <span class="id">sm0</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">LE</span>: (<span class="id">stack_contents_at_external</span> <span class="id">j</span> <span class="id">stack</span> <span class="id">cs</span>' <span class="id">sg</span>).(<span class="id">m_footprint</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stack_contents</span> <span class="id">j</span> <span class="id">stack</span> <span class="id">cs</span>').(<span class="id">m_footprint</span>)&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7429')">Proof.</div>
<div class="proofscript" id="proof7429">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">func_ext2</span>. <span class="id">i</span>. <span class="tactic">apply</span> <span class="id">prop_ext</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">size_arguments_above</span>; <span class="tactic">intro</span> <span class="id">SZARG</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="id">u</span>. <span class="tactic">split</span>; <span class="id">i</span>; <span class="id">des</span>; <span class="id">clarify</span>; <span class="id">esplits</span>; <span class="id">et</span>; <span class="id">psimpl</span>; <span class="id">zsimpl</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exploit</span> <span class="id">tailcall_size</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">specialize</span> (<span class="id">SZARG</span> <span class="id">sg</span>). <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">destruct</span> (<span class="id">classic</span> (4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">x1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">right</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">left</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">frame_contents</span> <span class="id">frame_contents_at_external</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STK</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;{ <span class="id">psimpl</span>. <span class="id">zsimpl</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">frame_contents_at_external_m_footprint</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">split</span>; <span class="tactic">try</span> <span class="id">xomega</span>. <span class="id">specialize</span> (<span class="id">SZARG</span> <span class="id">sg</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">bound_outgoing_stack_data</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">frame_contents_at_external_m_footprint</span> ;<span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">split</span>; <span class="tactic">try</span> <span class="id">xomega</span>. <span class="id">specialize</span> (<span class="id">SZARG</span> <span class="id">sg</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">bound_outgoing_stack_data</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;}<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_contents_footprint_irr</span>: <span class="kwd">forall</span> <span class="id">f</span> <span class="id">j0</span> <span class="id">j1</span> <span class="id">spb</span> <span class="id">ls0</span> <span class="id">ls1</span> <span class="id">sp</span> <span class="id">ra</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">frame_contents</span> <span class="id">f</span> <span class="id">j0</span> <span class="id">spb</span> <span class="id">ls0</span> <span class="id">ls1</span> <span class="id">sp</span> <span class="id">ra</span>).(<span class="id">m_footprint</span>) &lt;2=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">frame_contents</span> <span class="id">f</span> <span class="id">j1</span> <span class="id">spb</span> <span class="id">ls0</span> <span class="id">ls1</span> <span class="id">sp</span> <span class="id">ra</span>).(<span class="id">m_footprint</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7430')">Proof.</div>
<div class="proofscript" id="proof7430">
&nbsp;&nbsp;<span class="id">i</span>. <span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">mconj_footprint_le</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;<span class="id">abstr</span> (<span class="id">fe_ofs_callee_save</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>))) <span class="id">ofs</span>.<br/>
&nbsp;&nbsp;<span class="id">abstr</span> (<span class="id">used_callee_save</span> (<span class="id">function_bounds</span> <span class="id">f</span>)) <span class="id">rs</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">rs</span>. <span class="id">ginduction</span> <span class="id">rs</span>; <span class="id">i</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">et</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">stack_contents_footprint_irr</span>: <span class="kwd">forall</span> <span class="id">j0</span> <span class="id">j1</span> <span class="id">cs</span> <span class="id">cs</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stack_contents</span> <span class="id">j0</span> <span class="id">cs</span> <span class="id">cs</span>').(<span class="id">m_footprint</span>) &lt;2=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stack_contents</span> <span class="id">j1</span> <span class="id">cs</span> <span class="id">cs</span>').(<span class="id">m_footprint</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7431')">Proof.</div>
<div class="proofscript" id="proof7431">
&nbsp;&nbsp;<span class="id">i</span>. <span class="tactic">clear</span> - <span class="id">cs</span>. <span class="id">ginduction</span> <span class="id">cs</span>; <span class="id">i</span>; <span class="id">ss</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">frame_contents_footprint_irr</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">sepconj_footprint_le</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">frame_contents_footprint_irr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">IHcs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">freed_contains_locations_incr</span>: <span class="kwd">forall</span> <span class="id">j</span> <span class="id">j</span>' <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">massert_imp</span> (<span class="id">freed_contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">freed_contains_locations</span> <span class="id">j</span>' <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7432')">Proof.</div>
<div class="proofscript" id="proof7432">
 <span class="tactic">intros</span>; <span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_locations_tl_incr</span>: <span class="kwd">forall</span> <span class="id">j</span> <span class="id">j</span>' <span class="id">sp</span> <span class="id">pos</span> <span class="id">from</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">massert_imp</span> (<span class="id">contains_locations_tl</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">from</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">contains_locations_tl</span> <span class="id">j</span>' <span class="id">sp</span> <span class="id">pos</span> <span class="id">from</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7433')">Proof.</div>
<div class="proofscript" id="proof7433">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span> <span class="tactic">auto</span>. <span class="id">exploit</span> <span class="id">H4</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="id">exists</span> <span class="id">v</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">frame_contents_at_external</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">frame_contents_at_external_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">sg</span> <span class="id">m</span> <span class="id">P</span> <span class="id">j</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents_at_external</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">sg</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents_at_external</span> <span class="id">f</span> <span class="id">j</span>' <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">sg</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7434')">Proof.</div>
<div class="proofscript" id="proof7434">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents_at_external</span>, <span class="id">frame_contents_1_at_external</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- (<span class="id">contains_locations_incr</span> <span class="id">j</span> <span class="id">j</span>') <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">contains_callee_saves_incr</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">freed_contains_locations_incr</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">contains_locations_tl_incr</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
Qed.</div>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">frame_contents_at_external</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">stack_contents_at_external_change_meminj</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">j</span> <span class="id">j</span>', <span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">stack_contents_at_external</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">stack_contents_at_external</span> <span class="id">j</span>' <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7435')">Proof.</div>
<div class="proofscript" id="proof7435">
&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">cs</span> <span class="kwd">as</span> [ | [] <span class="id">cs</span>]; <span class="tactic">destruct</span> <span class="id">cs</span>' <span class="kwd">as</span> [ | [] <span class="id">cs</span>']; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">frame_contents_at_external_incr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">frame_contents_at_external_incr</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">sep_comm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">stack_contents_change_meminj</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">H</span>; <span class="id">des_ifs</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">sep_comm</span>. <span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">STACKINGEXTRA</span>.<br/>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">strong_wf_tgt</span> (<span class="id">st_tgt0</span>: <span class="id">Mach.state</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">parent_sp</span> <span class="id">parent_ra</span>, <span class="id">last_option</span> <span class="id">st_tgt0</span>.(<span class="id">MachC.get_stack</span>) = <span class="id">Some</span> (<span class="id">Mach.dummy_stack</span> <span class="id">parent_sp</span> <span class="id">parent_ra</span>).<br/>
<br/>
<br/>
<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">make_env</span> <span class="id">sepconj</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">contains_callee_saves_footprint</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span> <span class="id">sp</span> <span class="id">b</span> <span class="id">rs0</span> <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FOOT</span>: <span class="id">m_footprint</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> (<span class="id">fe_ofs_callee_save</span> (<span class="id">make_env</span> <span class="id">b</span>)) (<span class="id">used_callee_save</span> <span class="id">b</span>) <span class="id">rs0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sp</span> <span class="id">ofs</span>)<br/>
&nbsp;&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">BOUND</span>: <span class="id">fe_ofs_callee_save</span> (<span class="id">make_env</span> <span class="id">b</span>) &lt;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ofs</span> &lt; <span class="id">size_callee_save_area</span> <span class="id">b</span> (<span class="id">fe_ofs_callee_save</span> (<span class="id">make_env</span> <span class="id">b</span>))&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7436')">Proof.</div>
<div class="proofscript" id="proof7436">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">ss</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">size_callee_save_area</span>. <span class="id">ss</span>. <span class="id">clear_tac</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span>(4 | 8).<br/>
&nbsp;&nbsp;{ <span class="id">econs</span>. <span class="id">instantiate</span> (1:=2). <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span>(0 &lt; <span class="id">align</span> (4 * <span class="id">bound_outgoing</span>) 8 + 8 /\ (4 | <span class="id">align</span> (4 * <span class="id">bound_outgoing</span>) 8 + 8)).<br/>
&nbsp;&nbsp;{ <span class="id">hexploit</span> (<span class="id">align_le</span> (4 * <span class="id">bound_outgoing</span>) 8); <span class="tactic">try</span> <span class="id">lia</span>. <span class="id">i</span>. <span class="tactic">split</span>; <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Z.divide_add_r</span>; <span class="tactic">try</span> <span class="id">lia</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">etrans</span>; <span class="id">cycle</span> 1. <span class="tactic">eapply</span> <span class="id">align_divides</span>; <span class="tactic">try</span> <span class="id">lia</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;TODO:&nbsp;strengthen&nbsp;zsimpl.&nbsp;*)</span><br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="id">abstr</span> (<span class="id">align</span> (4 * <span class="id">bound_outgoing</span>) 8 + 8) <span class="id">initofs</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">bound_outgoing_pos</span> <span class="id">bound_stack_data_pos</span> <span class="id">bound_local_pos</span>. <span class="id">clear_tac</span>.<br/>
&nbsp;&nbsp;<span class="id">ginduction</span> <span class="id">used_callee_save</span>; <span class="id">ii</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span>((4 | (<span class="id">AST.typesize</span> (<span class="id">mreg_type</span> <span class="id">a</span>))) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">AST.typesize</span> (<span class="id">mreg_type</span> <span class="id">a</span>)) | 8) /\ 0 &lt; (<span class="id">AST.typesize</span> (<span class="id">mreg_type</span> <span class="id">a</span>))).<br/>
&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">a</span>; <span class="id">ss</span>; <span class="id">des_ifs</span>; <span class="id">cbn</span>; <span class="id">splits</span>; <span class="tactic">try</span> <span class="id">refl</span>; <span class="tactic">try</span> <span class="id">lia</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">FOOT</span>.<br/>
&nbsp;&nbsp;- <span class="id">des</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">etrans</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">align_le</span>; <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Z.lt_le_trans</span>; <span class="tactic">eauto</span>. <span class="id">etrans</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">size_callee_save_area_rec_incr</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">size_type_chunk</span>. <span class="id">refl</span>.<br/>
&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">IHused_callee_save</span>; <span class="id">revgoals</span>; <span class="id">cycle</span> 1; <span class="id">swap</span> 1 3; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">des</span>. <span class="tactic">eapply</span> <span class="id">Z.add_pos_pos</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Z.lt_le_trans</span>. <span class="tactic">eapply</span> <span class="id">H0</span>. <span class="tactic">eapply</span> <span class="id">align_le</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">des</span>. <span class="tactic">eapply</span> <span class="id">Z.divide_add_r</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Z.divide_trans</span>. <span class="tactic">eapply</span> <span class="id">H1</span>. <span class="tactic">eapply</span> <span class="id">align_divides</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">used_callee_save_norepet</span>. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="tactic">split</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>. <span class="tactic">assert</span>(<span class="id">initofs</span> &lt;= <span class="id">align</span> <span class="id">initofs</span> (<span class="id">AST.typesize</span> (<span class="id">mreg_type</span> <span class="id">a</span>))). <span class="tactic">eapply</span> <span class="id">align_le</span>; <span class="tactic">omega</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
Qed.</div>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">make_env</span> <span class="id">sepconj</span>.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Section</span> <span class="id">SIMMODSEM</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">skenv_link</span>: <span class="id">SkEnv.t</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sm_link</span>: <span class="id">SimMem.t</span>.<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">Linear.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">Mach.program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<span class="kwd">Variable</span> <span class="id">rao</span>: <span class="id">Mach.function</span> -&gt; <span class="id">Mach.code</span> -&gt; <span class="id">ptrofs</span> -&gt; <span class="kwd">Prop</span>.<br/>
<span class="kwd">Let</span> <span class="id">md_src</span>: <span class="id">Mod.t</span> := (<span class="id">LinearC.module</span> <span class="id">prog</span>).<br/>
<span class="kwd">Let</span> <span class="id">md_tgt</span>: <span class="id">Mod.t</span> := (<span class="id">MachC.module</span> <span class="id">tprog</span> <span class="id">rao</span>).<br/>
<span class="kwd">Hypothesis</span> (<span class="id">INCLSRC</span>: <span class="id">SkEnv.includes</span> <span class="id">skenv_link</span> <span class="id">md_src</span>.(<span class="id">Mod.sk</span>)).<br/>
<span class="kwd">Hypothesis</span> (<span class="id">INCLTGT</span>: <span class="id">SkEnv.includes</span> <span class="id">skenv_link</span> <span class="id">md_tgt</span>.(<span class="id">Mod.sk</span>)).<br/>
<span class="kwd">Hypothesis</span> (<span class="id">WF</span>: <span class="id">SkEnv.wf</span> <span class="id">skenv_link</span>).<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := (<span class="id">SkEnv.revive</span> (<span class="id">SkEnv.project</span> <span class="id">skenv_link</span> <span class="id">md_src</span>.(<span class="id">Mod.sk</span>)) <span class="id">prog</span>).<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := (<span class="id">SkEnv.revive</span> (<span class="id">SkEnv.project</span> <span class="id">skenv_link</span> <span class="id">md_tgt</span>.(<span class="id">Mod.sk</span>)) <span class="id">tprog</span>).<br/>
<span class="kwd">Hypothesis</span> <span class="id">return_address_offset_exists</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">sg</span> <span class="id">ros</span> <span class="id">c</span> <span class="id">v</span> (<span class="id">FUNCT</span>: <span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> (<span class="id">Internal</span> <span class="id">f</span>)),<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> (<span class="id">Mcall</span> <span class="id">sg</span> <span class="id">ros</span> :: <span class="id">c</span>) (<span class="id">fn_code</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ofs</span>, <span class="id">rao</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ofs</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">return_address_offset_deterministic</span>: <span class="kwd">forall</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ofs</span> <span class="id">ofs</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rao</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ofs</span> -&gt; <span class="id">rao</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ofs</span>' -&gt; <span class="id">ofs</span> = <span class="id">ofs</span>'.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">match_stacks</span> := <span class="id">match_stacks</span> <span class="id">skenv_link</span> <span class="id">skenv_link</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">msp</span>: <span class="id">ModSemPair.t</span> := <span class="id">ModSemPair.mk</span> (<span class="id">md_src</span> <span class="id">skenv_link</span>) (<span class="id">md_tgt</span> <span class="id">skenv_link</span>) (<span class="id">SimSymbId.mk</span> <span class="id">md_src</span> <span class="id">md_tgt</span>) <span class="id">sm_link</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated_inject</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sm0</span> <span class="id">fptr_src</span> <span class="id">fd_tgt</span> <span class="id">fptr_tgt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SIMGE</span>: <span class="id">Genv.match_genvs</span> (<span class="id">match_globdef</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>) <span class="id">eq</span> <span class="id">prog</span>) <span class="id">ge</span> <span class="id">tge</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SIMSKE</span>: <span class="id">SimSymb.sim_skenv</span> <span class="id">sm0</span> (<span class="id">ModSemPair.ss</span> <span class="id">msp</span>) (<span class="id">ModSem.skenv</span> (<span class="id">ModSemPair.src</span> <span class="id">msp</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ModSem.skenv</span> (<span class="id">ModSemPair.tgt</span> <span class="id">msp</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FUNCSRC</span>: <span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">fptr_tgt</span> = <span class="id">Some</span> <span class="id">fd_tgt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJ</span>: <span class="id">Val.inject</span> <span class="id">sm0</span>.(<span class="id">SimMemInj.inj</span>) <span class="id">fptr_src</span> <span class="id">fptr_tgt</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">SRCUB</span>: <span class="id">fptr_src</span> = <span class="id">Vundef</span>&gt;&gt; \/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">fd_src</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">FUNCTGT</span>: <span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">fptr_src</span> = <span class="id">Some</span> <span class="id">fd_src</span>&gt;&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ &lt;&lt;<span class="id">TRANSF</span>: <span class="id">transf_fundef</span> <span class="id">fd_src</span> = <span class="id">OK</span> <span class="id">fd_tgt</span>&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7437')">Proof.</div>
<div class="proofscript" id="proof7437">
&nbsp;&nbsp;<span class="id">ss</span>. <span class="id">inv</span> <span class="id">SIMSKE</span>.<br/>
&nbsp;&nbsp;<span class="id">hexploit</span> (<span class="id">bsim_internal_funct_inject</span> <span class="id">SIMGE</span>); <span class="id">et</span>.<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">SimMemInjC.skenv_inject_revive</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">ge</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSL</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_function_sig</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">tf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRANSFF</span>: <span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">Linear.fn_sig</span>) = <span class="id">tf</span>.(<span class="id">fn_sig</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7438')">Proof.</div>
<div class="proofscript" id="proof7438">
 <span class="tactic">unfold</span> <span class="id">transf_function</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>. Qed.</div>
<br/>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">Pos.of_nat</span>.<br/>
<span class="kwd">Lemma</span> <span class="id">init_match_frame_contents</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sm_arg</span> <span class="id">sg</span> <span class="id">m_tgt0</span> <span class="id">rs</span> <span class="id">vs_src</span> <span class="id">vs_tgt</span> <span class="id">ls</span> <span class="id">sm_init</span> <span class="id">sm_junkinj</span> <span class="id">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SIMSKE</span>: <span class="id">SimSymb.sim_skenv</span> <span class="id">sm_arg</span> (<span class="id">ModSemPair.ss</span> <span class="id">msp</span>) (<span class="id">ModSem.skenv</span> (<span class="id">ModSemPair.src</span> <span class="id">msp</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ModSem.skenv</span> (<span class="id">ModSemPair.tgt</span> <span class="id">msp</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STORE</span>: <span class="id">StoreArguments.store_arguments</span> <span class="id">sm_arg</span>.(<span class="id">SimMemInj.tgt</span>) <span class="id">rs</span> (<span class="id">typify_list</span> <span class="id">vs_tgt</span> <span class="id">sg</span>.(<span class="id">sig_args</span>)) <span class="id">sg</span> <span class="id">m_tgt0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SG</span>: 4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">Ptrofs.modulus</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LS</span>: <span class="id">LocationsC.fill_arguments</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">locset_copy</span> (<span class="id">sm_arg</span>.(<span class="id">SimMemInj.src</span>).(<span class="id">Mem.nextblock</span>).(<span class="id">Zpos</span>) - <span class="id">m_tgt0</span>.(<span class="id">Mem.nextblock</span>).(<span class="id">Zpos</span>)) <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">typify_list</span> <span class="id">vs_src</span> <span class="id">sg</span>.(<span class="id">sig_args</span>)) (<span class="id">loc_arguments</span> <span class="id">sg</span>) = <span class="id">Some</span> <span class="id">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SIMVS</span>: <span class="id">Val.inject_list</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_arg</span>) <span class="id">vs_src</span> <span class="id">vs_tgt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SM0</span>: <span class="id">sm_init</span> = <span class="id">sm_arg</span>.(<span class="id">SimMemInjC.update</span>) <span class="id">sm_arg</span>.(<span class="id">SimMemInj.src</span>) <span class="id">m_tgt0</span> <span class="id">sm_arg</span>.(<span class="id">SimMemInj.inj</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PRIV</span>: <span class="kwd">forall</span> <span class="id">ofs</span> (<span class="id">BDD</span>: 0 &lt;= <span class="id">ofs</span> &lt; 4 * <span class="id">size_arguments</span> <span class="id">sg</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">SimMemInj.tgt_private</span> <span class="id">sm_init</span> (<span class="id">Mem.nextblock</span> <span class="id">sm_arg</span>.(<span class="id">SimMemInj.tgt</span>)) <span class="id">ofs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MLE0</span>: <span class="id">SimMem.le</span> <span class="id">sm_arg</span> <span class="id">sm_init</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MWF0</span>: <span class="id">SimMem.wf</span> <span class="id">sm_init</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SM1</span>: <span class="id">sm_junkinj</span> = <span class="id">sm_init</span>.(<span class="id">SimMemInjC.update</span>) (<span class="id">assign_junk_blocks</span> <span class="id">sm_init</span>.(<span class="id">SimMemInj.src</span>) <span class="id">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">assign_junk_blocks</span> <span class="id">m_tgt0</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SimMemInjC.inject_junk_blocks</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sm_init</span>.(<span class="id">SimMemInj.src</span>) <span class="id">m_tgt0</span> <span class="id">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sm_arg</span>.(<span class="id">SimMemInj.inj</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MLE1</span>: <span class="id">SimMem.le</span> <span class="id">sm_init</span> <span class="id">sm_junkinj</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MWF1</span>: <span class="id">SimMem.wf</span> <span class="id">sm_junkinj</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NB</span>: <span class="id">Ple</span> (<span class="id">Genv.genv_next</span> (<span class="id">SkEnv.project</span> <span class="id">skenv_link</span> <span class="id">md_src</span>.(<span class="id">Mod.sk</span>))) (<span class="id">Mem.nextblock</span> <span class="id">m_tgt0</span>)):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assign_junk_blocks</span> <span class="id">m_tgt0</span> <span class="id">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|= <span class="id">dummy_frame_contents</span> <span class="id">sm_arg</span>.(<span class="id">SimMemInj.inj</span>) <span class="id">ls</span> <span class="id">sg</span> (<span class="id">Mem.nextblock</span> <span class="id">sm_arg</span>.(<span class="id">SimMemInj.tgt</span>)) 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">minjection</span> <span class="id">sm_junkinj</span>.(<span class="id">SimMemInj.inj</span>) <span class="id">sm_junkinj</span>.(<span class="id">SimMemInj.src</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">sm_junkinj</span>.(<span class="id">SimMemInj.inj</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7439')">Proof.</div>
<div class="proofscript" id="proof7439">
&nbsp;&nbsp;<span class="id">sep_split</span>.<br/>
&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="id">zsimpl</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">apply</span> <span class="id">Z.divide_0_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">STORE</span>. <span class="id">hexpl</span> <span class="id">Mem.alloc_result</span> <span class="id">NB</span>. <span class="id">clarify</span>. <span class="id">ii</span>. <span class="tactic">rewrite</span> <span class="id">assign_junk_blocks_perm</span>. <span class="tactic">eapply</span> <span class="id">PERM</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">clear</span> - <span class="id">SG</span> <span class="id">SIMVS</span> <span class="id">STORE</span> <span class="id">LS</span>. <span class="id">inv</span> <span class="id">STORE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexpl</span> <span class="id">LocationsC.fill_arguments_spec</span>. <span class="tactic">clear</span> <span class="id">LS</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexpl</span> <span class="id">Mem.alloc_result</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> ? ? <span class="id">OFS0</span> <span class="id">OFS1</span> <span class="id">ALIGN</span>. <span class="id">zsimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">In</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">hnf</span> <span class="kwd">in</span> <span class="id">VALS</span>. <span class="tactic">generalize</span> (<span class="id">loc_arguments_one</span> <span class="id">sg</span>); <span class="tactic">intro</span> <span class="id">ONES</span>. <span class="id">abstr</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>) <span class="id">locs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">OFS0</span> <span class="id">OFS1</span> <span class="id">SG</span> <span class="id">H</span> <span class="id">SIMVS</span> <span class="id">VALS</span> <span class="id">locs</span> <span class="id">ONES</span> <span class="id">FILL</span> <span class="id">ALC</span>. <span class="id">abstr</span> (<span class="id">sig_args</span> <span class="id">sg</span>) <span class="id">tys</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ginduction</span> <span class="id">locs</span>; <span class="id">ii</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">ONES</span>; <span class="tactic">eauto</span>. <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="id">ss</span>. <span class="id">des</span>; <span class="id">ss</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">typify_list</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">VALS</span>. <span class="id">inv</span> <span class="id">SIMVS</span>; <span class="id">ss</span>; <span class="id">des_ifs</span>. <span class="id">inv</span> <span class="id">H3</span>. <span class="id">inv</span> <span class="id">H7</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">typify</span> <span class="id">v</span>' <span class="id">t</span>). <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">load_stack</span>, <span class="id">Mem.loadv</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="id">zsimpl</span>. <span class="id">psimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">assign_junk_blocks_load</span>; <span class="id">ss</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">psimpl</span>. <span class="tactic">unfold</span> <span class="id">Ptrofs.max_unsigned</span> <span class="kwd">in</span> *. <span class="tactic">set</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>). <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> &lt;- <span class="id">H6</span>. <span class="tactic">eapply</span> <span class="id">inject_typify</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">typify_list</span> <span class="kwd">in</span> *. <span class="id">inv</span> <span class="id">VALS</span>. <span class="id">inv</span> <span class="id">SIMVS</span>; <span class="id">ss</span>; <span class="id">des_ifs</span>. <span class="tactic">eapply</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">OUT</span>; <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">Mem.valid_access_load</span> <span class="id">m_tgt0</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>)); <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">i</span>; <span class="id">des</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>. <span class="id">erewrite</span> <span class="id">assign_junk_blocks_load</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">erewrite</span> <span class="id">Stackingproof.size_type_chunk</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> <span class="id">Stackingproof.typesize_typesize</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_implies</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">PERM</span>. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">rewrite</span> <span class="id">Stackingproof.align_type_chunk</span>. <span class="tactic">eapply</span> <span class="id">Z.mul_divide_mono_l</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">disjoint_footprint_sepconj</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">bar</span>. <span class="id">ii</span>; <span class="id">ss</span>. <span class="tactic">rename</span> <span class="id">H</span> <span class="id">into</span> <span class="id">X</span>. <span class="tactic">rename</span> <span class="id">H0</span> <span class="id">into</span> <span class="id">Y</span>. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">clarify</span>. <span class="id">zsimpl</span>. <span class="id">specialize</span> (<span class="id">PRIV</span> <span class="id">ofs</span>). <span class="id">exploit</span> <span class="id">PRIV</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">TPRIV</span>. <span class="id">hnf</span> <span class="kwd">in</span> <span class="id">TPRIV</span>. <span class="id">ss</span>. <span class="id">des</span>. <span class="tactic">unfold</span> <span class="id">SimMemInjC.inject_junk_blocks</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">TPRIV</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">assign_junk_blocks_perm</span> <span class="kwd">in</span> *; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">bsimpl</span>; <span class="id">des</span>; <span class="id">des_sumbool</span>; <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">assign_junk_blocks_perm</span> <span class="kwd">in</span> *. <span class="id">zsimpl</span>. <span class="id">exploit</span> <span class="id">Mem.perm_valid_block</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">TPRIV</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">assign_junk_blocks_perm</span> <span class="kwd">in</span> *; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="id">sep_split</span>.<br/>
&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="id">inv</span> <span class="id">MWF1</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;{ <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SimMemInjC.sim_skenv_inj_globalenv_inject</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">SimSymb.mle_preserves_sim_skenv</span> <span class="kwd">in</span> <span class="id">SIMSKE</span>; <span class="id">et</span>. <span class="id">etrans</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">assign_junk_blocks_nextblock</span>. <span class="id">ss</span>. <span class="id">des_ifs</span>; <span class="id">xomega</span>. }<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">stack_contents_at_external_intro</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sm0</span> <span class="id">stack</span> <span class="id">cs</span>' <span class="id">sg</span> <span class="id">sp</span> <span class="id">sm1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">tge</span> <span class="id">_</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm0</span>) <span class="id">stack</span> <span class="id">cs</span>' <span class="id">sg</span> <span class="id">sm0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RSP</span>: <span class="id">parent_sp</span> <span class="id">cs</span>' = <span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FREETGT</span>: <span class="id">Mem.free</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm0</span>) <span class="id">sp</span> 0 (4 * <span class="id">size_arguments</span> <span class="id">sg</span>) = <span class="id">Some</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm1</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SEP</span>: <span class="id">SimMemInj.tgt</span> <span class="id">sm0</span> |= <span class="id">stack_contents</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm0</span>) <span class="id">stack</span> <span class="id">cs</span>'):<br/>
&nbsp;&nbsp;&lt;&lt;<span class="id">SEP</span>: <span class="id">SimMemInj.tgt</span> <span class="id">sm1</span> |= <span class="id">stack_contents_at_external</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm0</span>) <span class="id">stack</span> <span class="id">cs</span>' <span class="id">sg</span>&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7440')">Proof.</div>
<div class="proofscript" id="proof7440">
&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">Mem.nextblock_free</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">NB</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">stack</span>; <span class="id">ss</span>. <span class="tactic">destruct</span> <span class="id">cs</span>'; <span class="id">ss</span>. <span class="id">inv</span> <span class="id">STACKS</span>.<br/>
&nbsp;&nbsp;<span class="id">des_ifs_safe</span>. <span class="tactic">destruct</span> <span class="id">stack</span>.<br/>
&nbsp;&nbsp;{ <span class="id">des_ifs</span>; <span class="id">sep_simpl_tac</span>. <span class="id">psimpl</span>. <span class="tactic">unfold</span> <span class="id">dummy_frame_contents</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">contains_locations_range</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="id">zsimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">range_split0</span> <span class="kwd">with</span> (<span class="id">mid</span> := (4 * <span class="id">size_arguments</span> <span class="id">sg</span>)) <span class="kwd">in</span> <span class="id">SEP</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">generalize</span> (<span class="id">size_arguments_above</span> <span class="id">sg</span>); <span class="id">i</span>. <span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">des</span>; <span class="id">clarify</span>; <span class="id">ss</span>; <span class="tactic">split</span>; <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">erewrite</span> <span class="id">Conventions.tailcall_size</span>; <span class="tactic">eauto</span>. <span class="tactic">generalize</span> (<span class="id">size_arguments_above</span> <span class="id">sg_init</span>); <span class="id">i</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">STK</span>. <span class="id">inv</span> <span class="id">MAINARGS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SEP</span> <span class="kwd">as</span> (<span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>). <span class="id">sep_split</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ss</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>; <span class="tactic">try</span> <span class="id">lia</span>. <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.valid_block_free_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>. <span class="id">hexploit</span> <span class="id">A1</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_valid_block</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">m_invar</span>; <span class="tactic">eauto</span>. <span class="id">hexpl</span> <span class="id">Mem.free_unchanged_on</span> <span class="id">UNCH</span>. <span class="id">ii</span>. <span class="id">ss</span>. <span class="id">des</span>; <span class="id">clarify</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;TODO:&nbsp;Fix&nbsp;hexpl&nbsp;tactic&nbsp;*)</span><br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">stack_contents_args</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">cs</span>'; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">STACKS</span>. <span class="id">inv</span> <span class="id">STK</span>. }<br/>
&nbsp;&nbsp;<span class="id">des_ifs_safe</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_unchanged_on</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;{ <span class="id">instantiate</span> (1:= <span class="kwd">fun</span> <span class="id">blk</span> <span class="id">ofs</span> =&gt; <span class="id">blk</span> &lt;&gt; <span class="id">sp</span> \/ ~(0 &lt;= <span class="id">ofs</span> &lt; 4 * <span class="id">size_arguments</span> <span class="id">sg</span>)). <span class="id">ss</span>. <span class="id">ii</span>; <span class="id">des</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">UNCH</span>.<br/>
<br/>
&nbsp;&nbsp;{{ <span class="tactic">assert</span>(<span class="id">SZARG</span>: 0 &lt;= <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">bound_outgoing</span> (<span class="id">function_bounds</span> <span class="id">f</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">ss</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="tactic">generalize</span> (<span class="id">size_arguments_above</span> <span class="id">sg</span>). <span class="id">i</span>. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">SZARG0</span>: 4 * <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">fe_stack_data</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">generalize</span> (<span class="id">bound_outgoing_stack_data</span> (<span class="id">function_bounds</span> <span class="id">f</span>)); <span class="id">i</span>. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">UNCH0</span>: <span class="id">Mem.unchanged_on</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(~2 <span class="id">m_footprint</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">contains_locations</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm0</span>) <span class="id">sp</span> <span class="id">fe_ofs_arg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">bound_outgoing</span> (<span class="id">function_bounds</span> <span class="id">f</span>)) <span class="id">Outgoing</span> <span class="id">rs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SimMemInj.tgt</span> <span class="id">sm0</span>) (<span class="id">SimMemInj.tgt</span> <span class="id">sm1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_implies</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">bar</span>. <span class="tactic">intros</span> ? ? <span class="id">FOOT</span> <span class="id">VALID</span>. <span class="id">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="id">clarify</span>; <span class="id">et</span>. <span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">CONTR</span>. <span class="tactic">clear</span> - <span class="id">SZARG</span> <span class="id">CONTR</span> <span class="id">FOOT</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> (<span class="id">apply_all_once</span> <span class="id">not_and_or</span>). <span class="id">des</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">FOOT</span>; <span class="id">et</span>. <span class="tactic">unfold</span> <span class="id">fe_ofs_arg</span> <span class="kwd">in</span> *. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">UNCH1</span>: <span class="id">Mem.unchanged_on</span> (~2 <span class="id">m_footprint</span> (<span class="id">frame_contents</span> <span class="id">f</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sp</span> <span class="id">rs</span> <span class="id">rs0</span> <span class="id">sp2</span> <span class="id">retaddr0</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SimMemInj.tgt</span> <span class="id">sm0</span>) (<span class="id">SimMemInj.tgt</span> <span class="id">sm1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_implies</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">UNCH0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">ss</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="tactic">apply</span> <span class="id">not_or_and</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>. <span class="tactic">unfold</span> <span class="id">frame_contents_1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>. <span class="id">left</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_isolated_mutation_revisited</span>; <span class="id">et</span>; <span class="tactic">clear</span> <span class="id">UNCH1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents</span>, <span class="id">frame_contents_at_external</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">clear</span> <span class="id">SEP0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents_1</span>, <span class="id">frame_contents_1_at_external</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sep_swap</span>. <span class="tactic">rewrite</span> <span class="id">sep_swap23</span>. <span class="tactic">apply</span> <span class="id">sep_swap</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_isolated_mutation_revisited</span>; <span class="id">et</span>; <span class="id">swap</span> 2 3.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_implies</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">u</span>. <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">fe_ofs_arg</span> <span class="kwd">in</span> *. <span class="id">zsimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>; <span class="id">clarify</span>; <span class="id">esplits</span>; <span class="id">et</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">contains_locations_split</span> <span class="kwd">with</span> (<span class="id">lo</span> := (<span class="id">size_arguments</span> <span class="id">sg</span>)) <span class="kwd">in</span> <span class="id">SEP</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_isolated_mutation_revisited</span>; <span class="id">et</span>; <span class="id">swap</span> 2 3.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">free_freed_contains_locations</span> <span class="kwd">with</span> (<span class="id">CTX</span> := <span class="id">pure</span> <span class="id">True</span>); <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">add_pure_r_eq</span>. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">match_stacks_sp_valid</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_implies</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">UNCH</span>; <span class="id">et</span>. <span class="id">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">apply</span> <span class="id">not_and_or</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">des</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">clear</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">range_split</span> <span class="kwd">with</span> (<span class="id">mid</span> := (4 * <span class="id">size_arguments</span> <span class="id">sg</span>)) <span class="kwd">in</span> <span class="id">SEP0</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">esplits</span>; <span class="id">et</span>. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sep_simpl_tac</span>. <span class="tactic">eapply</span> <span class="id">sepconj_isolated_mutation_revisited</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_implies</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">UNCH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">ss</span>. <span class="tactic">apply</span> <span class="id">not_and_or</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">des</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">fe_ofs_arg</span>. <span class="id">zsimpl</span>. <span class="id">esplits</span>; <span class="id">et</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">SEP0</span>. <span class="id">ss</span>. <span class="id">des</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">i</span>. <span class="id">inv</span> <span class="id">STACKS</span>. <span class="id">des</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_block_free_1</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">frame_contents_at_external_m_footprint</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">bound_outgoing_stack_data</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}}<br/>
&nbsp;&nbsp;<span class="id">Unshelve</span>.<br/>
&nbsp;&nbsp;<span class="id">all</span>: <span class="id">econs</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">stack_contents_at_external_spec_elim</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sm_ret</span> <span class="id">stack</span> <span class="id">cs</span>' <span class="id">sg</span> <span class="id">sp</span> <span class="id">sm_after</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">tge</span> <span class="id">_</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_ret</span>) <span class="id">stack</span>.(<span class="id">stackframes_after_external</span>) <span class="id">cs</span>' <span class="id">sg</span> <span class="id">sm_after</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RSP</span>: <span class="id">parent_sp</span> <span class="id">cs</span>' = <span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">UNFREETGT</span>: <span class="id">Mem_unfree</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm_ret</span>) <span class="id">sp</span> 0 (4 * <span class="id">size_arguments</span> <span class="id">sg</span>) = <span class="id">Some</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm_after</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SEP</span>: <span class="id">SimMemInj.tgt</span> <span class="id">sm_ret</span> |= <span class="id">stack_contents_at_external</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_ret</span>) <span class="id">stack</span> <span class="id">cs</span>' <span class="id">sg</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">SEP</span>: <span class="id">SimMemInj.tgt</span> <span class="id">sm_after</span> |= <span class="id">stack_contents</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_ret</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack</span>.(<span class="id">stackframes_after_external</span>) <span class="id">cs</span>'&gt;&gt;.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7441')">Proof.</div>
<div class="proofscript" id="proof7441">
&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">Mem_nextblock_unfree</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">NB</span>.<br/>
&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">Mem_unfree_perm</span>; <span class="id">et</span>. <span class="tactic">intro</span> <span class="id">PERM</span>.<br/>
&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">Mem_unfree_unchanged_on</span>; <span class="id">et</span>. <span class="tactic">intro</span> <span class="id">UNCH</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">stack</span>; <span class="id">ss</span>. <span class="tactic">destruct</span> <span class="id">cs</span>'; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">STACKS</span>. <span class="id">inv</span> <span class="id">MAINARGS</span>. }<br/>
&nbsp;&nbsp;<span class="id">des_ifs_safe</span>. <span class="tactic">destruct</span> <span class="id">stack</span>.<br/>
&nbsp;&nbsp;{ <span class="id">des_ifs</span>; <span class="id">sep_simpl_tac</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">STK</span>. <span class="id">inv</span> <span class="id">MAINARGS</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">SZLE</span>: <span class="id">size_arguments</span> <span class="id">sg</span> &lt;= <span class="id">size_arguments</span> <span class="id">sg_init</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">des</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">refl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">tailcall_size</span>; <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">Z.ge_le</span>. <span class="tactic">eapply</span> <span class="id">size_arguments_above</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">stack_contents_args</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Local&nbsp;Opaque&nbsp;contains_locations.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">dummy_frame_contents</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">stack_contents_args</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">psimpl</span>. <span class="id">zsimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Z.divide_0_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">clear</span> - <span class="id">SEP</span>. <span class="id">inv</span> <span class="id">SEP</span>. <span class="id">des</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">des</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">des</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">tailcall_size</span>; <span class="id">et</span>. <span class="tactic">intro</span> <span class="id">ZERO</span>; <span class="id">des</span>. <span class="tactic">rewrite</span> <span class="id">ZERO</span> <span class="kwd">in</span> *. <span class="id">zsimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">SEP</span> <span class="id">UNCH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sep_drop</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="id">ss</span>. <span class="id">des</span>. <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_unchanged_on</span>; <span class="id">et</span>. <span class="id">u</span>. <span class="id">i</span>. <span class="id">des</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">i</span>. <span class="id">zsimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">exists</span> <span class="id">v</span>, <span class="id">Mem.load</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) (<span class="id">SimMemInj.tgt</span> <span class="id">sm_after</span>) <span class="id">sp</span> (4 * <span class="id">ofs</span>) = <span class="id">Some</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Mem.valid_access_load</span>. <span class="id">rr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">align_type_chunk</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> <span class="id">typesize_chunk</span> <span class="kwd">in</span> *. <span class="id">ii</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">ofs0</span> &lt; (4 * <span class="id">size_arguments</span> <span class="id">sg</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">PERM</span>; <span class="id">et</span>. <span class="tactic">split</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">Mem.perm_unchanged_on</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">u</span>. <span class="id">i</span>. <span class="id">des_safe</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">clear</span> - <span class="id">SEP</span> <span class="id">SZLE</span> <span class="id">H0</span> <span class="id">H2</span> <span class="id">H3</span>. <span class="tactic">apply</span> <span class="id">sep_drop</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="id">ss</span>. <span class="id">des</span>. <span class="tactic">eapply</span> <span class="id">SEP1</span>; <span class="id">et</span>. <span class="tactic">split</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Z.mul_divide_mono_l</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_safe</span>. <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">STACKS</span>. <span class="id">ss</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">stack_contents_args</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">stack_contents_args</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_isolated_mutation_revisited</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">generalize</span> (<span class="id">bound_outgoing_stack_data</span> (<span class="id">function_bounds</span> <span class="id">f</span>)); <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">frame_contents_at_external_m_footprint</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">bar</span>. <span class="id">u</span>. <span class="id">ii</span>. <span class="id">des</span>; <span class="id">clarify</span>. <span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">s</span>. <span class="id">left</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">split</span>; <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">Z.ge_le</span>. <span class="tactic">eapply</span> <span class="id">size_arguments_above</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">frame_contents</span> <span class="id">frame_contents_at_external</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="id">des</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">clear</span> <span class="id">SEP0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents_1</span>, <span class="id">frame_contents_1_at_external</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap</span>. <span class="tactic">rewrite</span> <span class="id">sep_swap</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">rewrite</span> <span class="id">sep_swap23</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sepconj_isolated_mutation_revisited</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">SEP</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">u</span>. <span class="id">ii</span>. <span class="id">des_safe</span>. <span class="tactic">unfold</span> <span class="id">fe_ofs_arg</span>. <span class="id">zsimpl</span>. <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">eapply</span> <span class="id">unfree_freed_contains_locations</span> <span class="kwd">with</span> (<span class="id">CTX</span> := <span class="id">pure</span> <span class="id">True</span>); <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">add_pure_r_eq</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">s</span>. <span class="id">ii</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="id">u</span>. <span class="tactic">unfold</span> <span class="id">fe_ofs_arg</span> <span class="kwd">in</span> *. <span class="id">zsimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">x1</span> &lt; 4 * <span class="id">size_arguments</span> <span class="id">sg</span>)); <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">split</span>; <span class="id">et</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">sepconj_isolated_mutation_revisited</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">SEP</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">u</span>. <span class="id">ii</span>. <span class="id">des_safe</span>. <span class="tactic">unfold</span> <span class="id">fe_ofs_arg</span>. <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">SEP0</span>. <span class="tactic">eapply</span> <span class="id">unfree_freed_range</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">s</span>. <span class="id">ii</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="id">u</span>. <span class="tactic">unfold</span> <span class="id">fe_ofs_arg</span> <span class="kwd">in</span> *. <span class="id">zsimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">x1</span> &lt; 4 * <span class="id">size_arguments</span> <span class="id">sg</span>)); <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">split</span>; <span class="id">et</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> &lt;- <span class="id">frame_contents_at_external_m_footprint</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">split</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">Z.ge_le</span>. <span class="tactic">eapply</span> <span class="id">size_arguments_above</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">bound_outgoing_stack_data</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;}<br/>
Qed.</div>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">sepconj</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">idx</span>: <span class="id">nat</span>) (<span class="id">st_src0</span>: <span class="id">Linear.state</span>) (<span class="id">st_tgt0</span>: <span class="id">MachC.state</span>) (<span class="id">sm0</span>: <span class="id">SimMem.t</span>): <span class="kwd">Prop</span> :=<br/>
| <span class="id">match_states_intro</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MATCHST</span>: <span class="id">Stackingproof.match_states</span> <span class="id">skenv_link</span> <span class="id">skenv_link</span> <span class="id">ge</span> <span class="id">tge</span> <span class="id">st_src0</span> <span class="id">st_tgt0</span>.(<span class="id">st</span>) <span class="id">sm0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MWF</span>: <span class="id">SimMem.wf</span> <span class="id">sm0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INITRS</span>: <span class="id">exists</span> <span class="id">dummy_stack_src</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">DUMMY</span>: <span class="id">st_src0</span>.(<span class="id">LinearC.get_stack</span>).(<span class="id">last_option</span>) = <span class="id">Some</span> <span class="id">dummy_stack_src</span>&gt;&gt; /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">GOOD</span>: <span class="kwd">forall</span> <span class="id">mr</span> (<span class="id">CALLEESAVE</span>: <span class="id">Conventions1.is_callee_save</span> <span class="id">mr</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;&lt;<span class="id">UIU</span>: <span class="id">dummy_stack_src</span>.(<span class="id">current_locset</span>) (<span class="id">R</span> <span class="id">mr</span>) = <span class="id">Vundef</span> -&gt; <span class="id">st_tgt0</span>.(<span class="id">init_rs</span>) <span class="id">mr</span> = <span class="id">Vundef</span>&gt;&gt;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ (&lt;&lt;<span class="id">INJ</span>: <span class="id">Val.inject</span> <span class="id">sm0</span>.(<span class="id">SimMemInj.inj</span>) (<span class="id">dummy_stack_src</span>.(<span class="id">current_locset</span>) (<span class="id">R</span> <span class="id">mr</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">st_tgt0</span>.(<span class="id">init_rs</span>) <span class="id">mr</span>)&gt;&gt;)&gt;&gt; /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;<span class="id">SIG</span>: <span class="id">dummy_stack_src</span>.(<span class="id">current_function</span>).(<span class="id">Linear.fn_sig</span>) = <span class="id">st_tgt0</span>.(<span class="id">init_sg</span>)&gt;&gt;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">WFTGT</span>: <span class="id">strong_wf_tgt</span> <span class="id">st_tgt0</span>.(<span class="id">MachC.st</span>)).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states_at</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">st_src0</span>: <span class="id">Linear.state</span>) (<span class="id">st_tgt0</span>: <span class="id">MachC.state</span>) (<span class="id">sm_at</span> <span class="id">sm_arg</span>: <span class="id">SimMem.t</span>): <span class="kwd">Prop</span> :=<br/>
| <span class="id">match_states_at_intro</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJ</span>: <span class="id">sm_at</span>.(<span class="id">SimMemInj.inj</span>) = <span class="id">sm_arg</span>.(<span class="id">SimMemInj.inj</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJ</span>: <span class="id">sm_at</span>.(<span class="id">SimMem.src</span>) = <span class="id">sm_arg</span>.(<span class="id">SimMem.src</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">init_rs</span> <span class="id">init_sg</span> <span class="id">cs</span>' <span class="id">tfptr</span> <span class="id">rs</span> <span class="id">sp</span> <span class="id">skd</span> <span class="id">fptr</span> <span class="id">cs</span> <span class="id">ls</span> <span class="id">sig</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SIGEQ</span>: <span class="id">Sk.get_csig</span> <span class="id">skd</span> = <span class="id">Some</span> <span class="id">sig</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SRCST</span>: <span class="id">st_src0</span> = <span class="id">Linear.Callstate</span> <span class="id">cs</span> <span class="id">fptr</span> <span class="id">sig</span> <span class="id">ls</span> (<span class="id">SimMemInj.src</span> <span class="id">sm_arg</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TGTST</span>: <span class="id">st_tgt0</span> = <span class="id">mkstate</span> <span class="id">init_rs</span> <span class="id">init_sg</span> (<span class="id">Callstate</span> <span class="id">cs</span>' <span class="id">tfptr</span> <span class="id">rs</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm_at</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RSP</span>: <span class="id">parent_sp</span> <span class="id">cs</span>' = <span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PRIV</span>: <span class="id">brange</span> <span class="id">sp</span> 0 (4 * <span class="id">size_arguments</span> <span class="id">sig</span>) &lt;2= <span class="id">sm_arg</span>.(<span class="id">SimMemInj.tgt_private</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SIG</span>: <span class="id">Genv.find_funct</span> <span class="id">skenv_link</span> <span class="id">fptr</span> = <span class="id">Some</span> <span class="id">skd</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VALID</span>: <span class="id">Mem.valid_block</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm_arg</span>) <span class="id">sp</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NB</span>: <span class="id">sm_at</span>.(<span class="id">SimMem.tgt</span>).(<span class="id">Mem.nextblock</span>) = <span class="id">sm_arg</span>.(<span class="id">SimMem.tgt</span>).(<span class="id">Mem.nextblock</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SEP</span>: <span class="id">SimMemInj.tgt</span> <span class="id">sm_arg</span> |= <span class="id">stack_contents_at_external</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_arg</span>) <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sig</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">minjection</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_arg</span>) (<span class="id">SimMemInj.src</span> <span class="id">sm_arg</span>) **<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">globalenv_inject</span> <span class="id">ge</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_arg</span>)).<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">make_match_genvs</span> :<br/>
&nbsp;&nbsp;<span class="id">SimSymbId.sim_skenv</span> (<span class="id">SkEnv.project</span> <span class="id">skenv_link</span> <span class="id">md_src</span>.(<span class="id">Mod.sk</span>)) (<span class="id">SkEnv.project</span> <span class="id">skenv_link</span> <span class="id">md_tgt</span>.(<span class="id">Mod.sk</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.match_genvs</span> (<span class="id">match_globdef</span> (<span class="kwd">fun</span> <span class="id">cunit</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>) <span class="id">eq</span> <span class="id">prog</span>) <span class="id">ge</span> <span class="id">tge</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7442')">Proof.</div>
<div class="proofscript" id="proof7442">
 <span class="id">subst_locals</span>. <span class="tactic">eapply</span> <span class="id">SimSymbId.sim_skenv_revive</span>; <span class="tactic">eauto</span>. Qed.</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">has_footprint</span> (<span class="id">st_src0</span>: <span class="id">Linear.state</span>): <span class="id">MachC.state</span> -&gt; <span class="id">SimMem.t</span> -&gt; <span class="kwd">Prop</span> :=<br/>
| <span class="id">has_footprint_intro</span><br/>
<div class="doc">copied from MachC *</div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stack</span> <span class="id">rs</span> <span class="id">m0</span> <span class="id">fptr</span> <span class="id">sg</span> <span class="id">blk</span> <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SIG</span>: <span class="id">exists</span> <span class="id">skd</span>, <span class="id">skenv_link</span>.(<span class="id">Genv.find_funct</span>) <span class="id">fptr</span> = <span class="id">Some</span> <span class="id">skd</span> /\ <span class="id">Sk.get_csig</span> <span class="id">skd</span> = <span class="id">Some</span> <span class="id">sg</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RSP</span>: (<span class="id">parent_sp</span> <span class="id">stack</span>) = <span class="id">Vptr</span> <span class="id">blk</span> <span class="id">ofs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">OFSZERO</span>: <span class="id">ofs</span> = <span class="id">Ptrofs.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">init_rs</span> <span class="id">init_sg</span><br/>
<div class="doc">newly added *</div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sm0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FOOT</span>: <span class="id">SimMemInjC.has_footprint</span> <span class="id">bot2</span> (<span class="id">brange</span> <span class="id">blk</span> (<span class="id">ofs</span>.(<span class="id">Ptrofs.unsigned</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ofs</span>.(<span class="id">Ptrofs.unsigned</span>) + 4 * (<span class="id">size_arguments</span> <span class="id">sg</span>))) <span class="id">sm0</span>)<br/>
:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">has_footprint</span> <span class="id">st_src0</span> (<span class="id">mkstate</span> <span class="id">init_rs</span> <span class="id">init_sg</span> (<span class="id">Callstate</span> <span class="id">stack</span> <span class="id">fptr</span> <span class="id">rs</span> <span class="id">m0</span>)) <span class="id">sm0</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">mle_excl</span> (<span class="id">st_src0</span>: <span class="id">Linear.state</span>): <span class="id">MachC.state</span> -&gt; <span class="id">SimMem.t</span> -&gt; <span class="id">SimMem.t</span> -&gt; <span class="kwd">Prop</span> :=<br/>
| <span class="id">mle_excl_intro</span><br/>
<div class="doc">copied from MachC *</div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">init_rs</span> <span class="id">init_sg</span> <span class="id">stack</span> <span class="id">fptr</span> <span class="id">ls0</span> <span class="id">m0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sg</span> <span class="id">blk</span> <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SIG</span>: <span class="id">exists</span> <span class="id">skd</span>, <span class="id">skenv_link</span>.(<span class="id">Genv.find_funct</span>) <span class="id">fptr</span> = <span class="id">Some</span> <span class="id">skd</span> /\ <span class="id">Sk.get_csig</span> <span class="id">skd</span> = <span class="id">Some</span> <span class="id">sg</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RSP</span>: (<span class="id">parent_sp</span> <span class="id">stack</span>) = <span class="id">Vptr</span> <span class="id">blk</span> <span class="id">ofs</span>)<br/>
<div class="doc">newly added *</div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sm0</span> <span class="id">sm1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MLEEXCL</span>: <span class="id">SimMemInjC.le_excl</span> <span class="id">bot2</span> (<span class="id">brange</span> <span class="id">blk</span> (<span class="id">ofs</span>.(<span class="id">Ptrofs.unsigned</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ofs</span>.(<span class="id">Ptrofs.unsigned</span>) + 4 * (<span class="id">size_arguments</span> <span class="id">sg</span>))) <span class="id">sm0</span> <span class="id">sm1</span>)<br/>
:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mle_excl</span> <span class="id">st_src0</span> (<span class="id">mkstate</span> <span class="id">init_rs</span> <span class="id">init_sg</span> (<span class="id">Callstate</span> <span class="id">stack</span> <span class="id">fptr</span> <span class="id">ls0</span> <span class="id">m0</span>)) <span class="id">sm0</span> <span class="id">sm1</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">SEGESRC</span>: <span class="id">senv_genv_compat</span> <span class="id">skenv_link</span> <span class="id">ge</span>. <span class="kwd">Proof</span>. <span class="tactic">eapply</span> <span class="id">SkEnv.senv_genv_compat</span>; <span class="id">et</span>. Qed.</div>
<span class="kwd">Let</span> <span class="id">SEGETGT</span>: <span class="id">senv_genv_compat</span> <span class="id">skenv_link</span> <span class="id">tge</span>. <span class="kwd">Proof</span>. <span class="tactic">eapply</span> <span class="id">SkEnv.senv_genv_compat</span>; <span class="id">et</span>. Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">sim_modsem</span>:<span class="id">ModSemPair.sim</span> <span class="id">msp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7443')">Proof.</div>
<div class="proofscript" id="proof7443">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_sim</span> <span class="kwd">with</span> (<span class="id">match_states</span> := <span class="id">match_states</span>) (<span class="id">match_states_at</span> := <span class="id">match_states_at</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sidx</span> := <span class="id">unit</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sound_states</span> := <span class="kwd">fun</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="id">wt_state</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">has_footprint</span> := <span class="id">has_footprint</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mle_excl</span> := <span class="id">mle_excl</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>; <span class="id">ii</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;- <span class="id">instantiate</span> (1:= <span class="id">Nat.lt</span>). <span class="tactic">apply</span> <span class="id">lt_wf</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">wt_state_local_preservation</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">wt_prog</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">FOOT</span>. <span class="id">inv</span> <span class="id">MLEEXCL</span>. <span class="tactic">rewrite</span> <span class="id">RSP</span> <span class="kwd">in</span> *. <span class="id">clarify</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="tactic">eapply</span> <span class="id">SimMemInjC.foot_excl</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;init&nbsp;bsim&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">INITTGT</span>. <span class="id">inv</span> <span class="id">STORE</span>. <span class="id">folder</span>. <span class="id">inv</span> <span class="id">SIMARGS</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">functions_translated_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">make_match_genvs</span>; <span class="id">et</span>. <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">SAFESRC</span>. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">fd_src</span>; <span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">bind</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexpl</span> <span class="id">transf_function_sig</span> <span class="id">SG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">LEN0</span>: <span class="id">length</span> (<span class="id">typify_list</span> <span class="id">vs_src</span> (<span class="id">sig_args</span> (<span class="id">Linear.fn_sig</span> <span class="id">f</span>))) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">length</span> (<span class="id">loc_arguments</span> (<span class="id">Linear.fn_sig</span> <span class="id">f</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">etransitivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">typify_list</span>. <span class="tactic">rewrite</span> <span class="id">zip_length</span>. <span class="id">erewrite</span> <span class="id">SimMem.sim_val_list_length</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">VALS0</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">symmetry</span>. <span class="tactic">rewrite</span> <span class="id">SG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;eapply&nbsp;extcall_arguments_imply&nbsp;in&nbsp;VALS.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">extcall_arguments_length</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>((<span class="id">length</span> <span class="id">targs</span>) = (<span class="id">length</span> (<span class="id">sig_args</span> (<span class="id">fn_sig</span> <span class="id">fd</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">erewrite</span> &lt;- <span class="id">extcall_arguments_length</span>; <span class="tactic">eauto</span>. <span class="id">erewrite</span> <span class="id">loc_arguments_length</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TYP</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">LocationsC.fill_arguments_progress</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">locset_copy</span> ((<span class="id">SimMemInj.src</span> <span class="id">sm_arg</span>).(<span class="id">Mem.nextblock</span>).(<span class="id">Zpos</span>) - <span class="id">m0</span>.(<span class="id">Mem.nextblock</span>).(<span class="id">Zpos</span>)) <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">typify_list</span> <span class="id">vs_src</span> (<span class="id">sig_args</span> (<span class="id">Linear.fn_sig</span> <span class="id">f</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;args_src.(Args.vs)&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">loc_arguments</span> <span class="id">f</span>.(<span class="id">Linear.fn_sig</span>))); <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">LocationsC.fill_arguments_spec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">typify_list</span> <span class="id">vs_src</span> (<span class="id">sig_args</span> (<span class="id">Linear.fn_sig</span> <span class="id">f</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;args_src.(Args.vs)&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">Linear.fn_sig</span>)); <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">MachExtra.mach_store_arguments_simmem</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">econs</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (@<span class="id">SimMemInjC.inject_junk_blocks_parallel</span> <span class="id">sm1</span> <span class="id">n</span>); <span class="id">et</span>. <span class="tactic">intro</span> <span class="id">SM0</span>; <span class="id">des</span>. <span class="tactic">rename</span> <span class="id">sm0</span> <span class="id">into</span> <span class="id">sm2</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="comment">(*&nbsp;initial&nbsp;frame&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>; <span class="id">cycle</span> 2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">instantiate</span> (1:= <span class="id">n</span>). <span class="id">ii</span>. <span class="id">hexpl</span> <span class="id">OUT</span>. <span class="tactic">destruct</span> <span class="id">loc</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">hexploit</span> <span class="id">PTRFREE</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">SG</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">OUT0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">SM</span> <span class="comment">(*&nbsp;NB&nbsp;*)</span> <span class="id">H</span>. <span class="id">des_ifs</span>. <span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">assign_junk_blocks_nextblock</span> <span class="kwd">in</span> *. <span class="tactic">unfold</span> <span class="id">Plt</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">abstr</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>) <span class="id">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">abstr</span> (<span class="id">Mem.nextblock</span> (<span class="id">SimMemInj.src</span> <span class="id">sm_arg</span>)) <span class="id">m_src</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Ltac</span> <span class="id">Pos_compare_tac</span> := <span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pos.compare_lt_iff</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">Pos.compare_gt_iff</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply_all_once</span> <span class="id">Pos.compare_eq</span>; <span class="id">clarify</span>; <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">Z.pos</span> <span class="id">b</span> + <span class="id">Z.pos_sub</span> <span class="id">m_src</span> <span class="id">y</span>) <span class="kwd">with</span> (<span class="id">Z.pos_sub</span> <span class="id">b</span> <span class="id">y</span> + <span class="id">Z.pos</span> <span class="id">m_src</span>); <span class="tactic">try</span> <span class="id">nia</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> ! <span class="id">Z.pos_sub_spec</span>. <span class="id">des_ifs</span>; <span class="id">Pos_compare_tac</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">ii</span>. <span class="tactic">rewrite</span> <span class="id">Z2Pos.inj_add</span> <span class="kwd">in</span> *; <span class="id">ss</span>; <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">Z.pos_sub_spec</span>. <span class="id">des_ifs</span>; <span class="id">Pos_compare_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Z.pos_sub_diag</span> <span class="kwd">in</span> *. <span class="id">zsimpl</span>. <span class="tactic">rewrite</span> <span class="id">Pos2Z.id</span> <span class="kwd">in</span> *. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">b</span> <span class="id">y</span>); <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">clarify</span>. <span class="tactic">rewrite</span> <span class="id">Z.pos_sub_diag</span>. <span class="id">zsimpl</span>. <span class="tactic">rewrite</span> <span class="id">Pos2Z.id</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>; <span class="id">lia</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Z2Pos.inj_add</span> <span class="kwd">in</span> *; <span class="id">ss</span>; <span class="tactic">try</span> <span class="id">lia</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> ! <span class="id">Z.pos_sub_spec</span>. <span class="id">des_ifs</span>; <span class="id">Pos_compare_tac</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">Z.pos_sub</span> <span class="id">b</span> <span class="id">y</span>) <span class="kwd">with</span> (<span class="id">b</span>.(<span class="id">Zpos</span>) - <span class="id">y</span>.(<span class="id">Zpos</span>))%<span class="id">Z</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Z2Pos.inj_sub</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>; <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">OUT0</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">ii</span>. <span class="id">hexpl</span> <span class="id">OUT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">esplits</span>; <span class="id">ss</span>. <span class="tactic">clear</span> - <span class="id">Heq</span> <span class="id">CSTYLE0</span>. <span class="tactic">unfold</span> <span class="id">transf_function</span> <span class="kwd">in</span> <span class="id">Heq</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">TYP</span>. <span class="id">econs</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">SimMem.sim_val_list_length</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">VALS0</span>. <span class="id">ss</span>. <span class="id">etrans</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">instantiate</span> (1:= <span class="id">sm2</span>). <span class="id">etrans</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="comment">(*&nbsp;match&nbsp;states&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">INITRS</span>: <span class="id">agree_regs</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm2</span>) <span class="id">ls1</span> <span class="id">rs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">destruct</span> (<span class="id">classic</span> (<span class="id">In</span> (<span class="id">R</span> <span class="id">r</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> (<span class="id">Linear.fn_sig</span> <span class="id">f</span>))))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">red</span> <span class="kwd">in</span> <span class="id">VALS</span>. <span class="id">inv</span> <span class="id">TYP</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">SG</span> <span class="kwd">in</span> *. <span class="tactic">clear</span> - <span class="id">FILL</span> <span class="id">VALS</span> <span class="id">VALS0</span> <span class="id">H</span> <span class="id">MLE0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">loc_arguments_one</span> (<span class="id">Linear.fn_sig</span> <span class="id">f</span>)). <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">abstr</span> (<span class="id">loc_arguments</span> (<span class="id">Linear.fn_sig</span> <span class="id">f</span>)) <span class="id">locs</span>. <span class="id">clear_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">abstr</span> <span class="id">vs_src</span> <span class="id">vals_src</span>. <span class="id">abstr</span> <span class="id">vs_tgt</span> <span class="id">vals_tgt</span>. <span class="id">clear_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">abstr</span> (<span class="id">sig_args</span> (<span class="id">Linear.fn_sig</span> <span class="id">f</span>)) <span class="id">tys</span>. <span class="id">clear_tac</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">typify_list</span> <span class="kwd">in</span> *. <span class="id">ginduction</span> <span class="id">locs</span>; <span class="id">ii</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="tactic">destruct</span> <span class="id">a</span>; <span class="id">ss</span>. <span class="id">des</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">VALS</span>. <span class="tactic">destruct</span> <span class="id">vals_tgt</span>; <span class="id">ss</span>. <span class="id">des_ifs</span>. <span class="id">inv</span> <span class="id">VALS0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rename</span> <span class="id">H4</span> <span class="id">into</span> <span class="id">EARGP</span>. <span class="id">inv</span> <span class="id">EARGP</span>. <span class="tactic">rename</span> <span class="id">H2</span> <span class="id">into</span> <span class="id">EARG</span>. <span class="id">inv</span> <span class="id">EARG</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">clarify</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H4</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">eapply</span> <span class="id">inject_typify</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MLE0</span>. <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">val_inject_incr</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">VALS</span>. <span class="tactic">destruct</span> <span class="id">vals_tgt</span>; <span class="id">ss</span>. <span class="id">des_ifs</span>. <span class="id">inv</span> <span class="id">VALS0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">typify_list</span> <span class="kwd">in</span> *. <span class="id">ss</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="comment">(*&nbsp;eapply&nbsp;Loc_not_in_notin_R&nbsp;in&nbsp;H;&nbsp;eauto.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">PTRFREE</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">SG</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="tactic">rewrite</span> <span class="id">OUT</span>; <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">DEF</span>. <span class="id">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">H0</span> <span class="id">MWF0</span> <span class="id">SM</span> <span class="id">DEF</span> <span class="id">MLE0</span>. <span class="id">des_ifs</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">instantiate</span> (1:= 0%<span class="id">Z</span>). <span class="id">psimpl</span>. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">SimMemInjC.inject_junk_blocks</span>. <span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">assign_junk_blocks_nextblock</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">abstr</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>) <span class="id">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">abstr</span> (<span class="id">Mem.nextblock</span> (<span class="id">SimMemInj.src</span> <span class="id">sm_arg</span>)) <span class="id">m_src</span>. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">Z.pos</span> <span class="id">b</span> + <span class="id">Z.pos_sub</span> <span class="id">m_src</span> <span class="id">y</span>) <span class="kwd">with</span> (<span class="id">Z.pos_sub</span> <span class="id">b</span> <span class="id">y</span> + <span class="id">Z.pos</span> <span class="id">m_src</span>); <span class="tactic">try</span> <span class="id">nia</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> ! <span class="id">Z.pos_sub_spec</span>. <span class="id">des_ifs</span>; <span class="id">Pos_compare_tac</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">b</span> <span class="id">y</span>) <span class="id">eqn</span>: <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">clarify</span>. <span class="tactic">rewrite</span> <span class="id">Z.pos_sub_diag</span>. <span class="id">zsimpl</span>. <span class="tactic">rewrite</span> <span class="id">Pos2Z.id</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>; <span class="id">bsimpl</span>; <span class="id">des</span>; <span class="id">des_sumbool</span>; <span class="tactic">try</span> <span class="id">xomega</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">m_src</span> + <span class="id">y</span> - <span class="id">m_src</span>)%<span class="id">positive</span> <span class="kwd">with</span> <span class="id">y</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Pos.add_comm</span>. <span class="tactic">rewrite</span> <span class="id">Pos.add_sub</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Z2Pos.inj_add</span>; <span class="id">ss</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> ! <span class="id">Z.pos_sub_spec</span>. <span class="id">des_ifs</span>; <span class="id">Pos_compare_tac</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">bsimpl</span>; <span class="id">des</span>; <span class="id">des_sumbool</span>. <span class="tactic">unfold</span> <span class="id">Plt</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Pos.add_comm</span>. <span class="tactic">rewrite</span> <span class="id">Pos.add_assoc</span>. <span class="tactic">rewrite</span> <span class="id">Pos.add_sub</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">Z.pos_sub_spec</span>. <span class="id">des_ifs</span>; <span class="id">Pos_compare_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Pos2Z.id</span>. <span class="tactic">rewrite</span> <span class="id">Pos.add_sub_assoc</span>; <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">Pos.add_comm</span>. <span class="tactic">rewrite</span> <span class="id">Pos.add_sub</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">COND0</span>: <span class="id">negb</span> (<span class="id">plt</span> (<span class="id">Z.to_pos</span> (<span class="id">Z.pos_sub</span> <span class="id">b</span> <span class="id">y</span>) + <span class="id">m_src</span>) <span class="id">m_src</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">bsimpl</span>. <span class="id">des_sumbool</span>. <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Plt</span> <span class="kwd">in</span> *. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;des_ifs.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;{&nbsp;unfold&nbsp;block.&nbsp;do&nbsp;2&nbsp;f_equal.&nbsp;bsimpl;&nbsp;des;&nbsp;des_sumbool;&nbsp;try&nbsp;lia.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">COND0</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">COND1</span>: <span class="id">plt</span> (<span class="id">Z.to_pos</span> (<span class="id">Z.pos_sub</span> <span class="id">b</span> <span class="id">y</span>) + <span class="id">m_src</span>) (<span class="id">m_src</span> + <span class="id">Pos.of_nat</span> <span class="id">n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">bsimpl</span>. <span class="id">des_sumbool</span>. <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Plt</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> ! <span class="id">Z.pos_sub_spec</span>. <span class="id">des_ifs</span>; <span class="id">Pos_compare_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="id">ss</span>; <span class="tactic">try</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">COND1</span> <span class="kwd">in</span> *. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rename</span> <span class="id">targs</span> <span class="id">into</span> <span class="id">targs_tgt</span>. <span class="tactic">rename</span> <span class="id">TYP</span> <span class="id">into</span> <span class="id">TYPTGT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">DEF</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">SM</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">inversion</span> <span class="id">SIMSKENV</span>; <span class="tactic">clear</span> <span class="id">SIMSKENV</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SimMemInjC.sim_skenv_symbols_inject</span> <span class="kwd">with</span> (<span class="id">sm0</span> := <span class="id">sm2</span>); <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SimSymb.mle_preserves_sim_skenv</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">SimSymb.mle_preserves_sim_skenv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">loc_arguments_bounded</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">rewrite</span> <span class="id">DEF</span>. <span class="tactic">rewrite</span> <span class="id">SM</span>. <span class="id">s</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span>. <span class="tactic">rewrite</span> <span class="id">assign_junk_blocks_nextblock</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">NB</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="id">et</span>. <span class="id">i</span>. <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">ALC</span> <span class="id">NB</span> <span class="id">MWF</span>. <span class="id">esplits</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">des_ifs</span>; <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">MWF</span>. <span class="id">etrans</span>; <span class="id">et</span>. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="comment">(*&nbsp;TODO:&nbsp;make&nbsp;lemma&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">inv</span> <span class="id">MWF</span>; <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">TGTEXT</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rr</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">ss</span>. <span class="id">des</span>. <span class="id">r</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="id">et</span>. <span class="id">i</span>. <span class="tactic">rewrite</span> <span class="id">NB</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> *. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">val_inject_incr</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE0</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">val_inject_incr</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">psimpl</span>. <span class="id">zsimpl</span>. <span class="tactic">rewrite</span> <span class="id">SG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (@<span class="id">init_match_frame_contents</span> <span class="id">sm_arg</span>); <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE0</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">TYPTGT</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exploit</span> <span class="id">SkEnv.revive_incl_skenv</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">INCLTGT</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">des</span>. <span class="id">inv</span> <span class="id">WF</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">WFPARAM</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">Ptrofs.max_unsigned</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">red</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">SG</span>. <span class="id">ss</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">DEF</span>, <span class="id">SM</span>. <span class="id">s</span>. <span class="tactic">f_equal</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">SIMSKENV</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">SIMSKE</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">etrans</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MWF0</span>. <span class="id">ss</span>. <span class="id">etrans</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MWF</span>. <span class="tactic">rewrite</span> <span class="id">NBTGT</span>. <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">dummy_frame_contents_incr</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE0</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">dummy_frame_contents_incr</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">esplits</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">i</span>. <span class="id">ss</span>. <span class="tactic">split</span>; <span class="id">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">rewrite</span> <span class="id">OUT</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">des_ifs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">hexpl</span> <span class="id">loc_arguments_acceptable_2</span> <span class="id">ACCP</span>. <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">rr</span>. <span class="id">ss</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;init&nbsp;progress&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>. <span class="id">inv</span> <span class="id">SAFESRC</span>. <span class="id">folder</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">make_match_genvs</span>; <span class="tactic">eauto</span>. { <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. } <span class="tactic">intro</span> <span class="id">SIMGE</span>. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">SIMARGS</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">fsim_internal_funct_inject</span> <span class="id">SIMGE</span>); <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">ge</span>. <span class="tactic">eapply</span> <span class="id">SimMemInjC.skenv_inject_revive</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">SIMSKENV</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des</span>. <span class="id">monadInv</span> <span class="id">MATCH</span>. <span class="tactic">rename</span> <span class="id">x</span> <span class="id">into</span> <span class="id">fd_tgt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">exists</span> <span class="id">targs_tgt</span>, &lt;&lt;<span class="id">TYPTGT</span>: <span class="id">typecheck</span> <span class="id">vs_tgt</span> (<span class="id">fn_sig</span> <span class="id">fd_tgt</span>) <span class="id">targs_tgt</span>&gt;&gt;).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">TYP</span>. <span class="id">eexists</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">inject_list_length</span>; <span class="tactic">eauto</span>. <span class="id">erewrite</span> &lt;- <span class="id">transf_function_sig</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">store_arguments_progress</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm_arg</span>) <span class="id">targs_tgt</span> (<span class="id">fn_sig</span> <span class="id">fd_tgt</span>)); <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">TYPTGT</span>. <span class="tactic">eapply</span> <span class="id">typify_has_type_list</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exploit</span> <span class="id">SkEnv.revive_incl_skenv</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">INCLTGT</span>; <span class="tactic">eauto</span>. <span class="id">i</span>. <span class="id">des</span>. <span class="id">inv</span> <span class="id">WF</span>. <span class="tactic">eapply</span> <span class="id">WFPARAM</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="id">econs</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">esplits</span>; <span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">transf_function</span> <span class="kwd">in</span> <span class="id">EQ</span>. <span class="id">des_ifs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">instantiate</span> (1:= <span class="id">Vlong</span> <span class="id">Int64.zero</span>). <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;callstate&nbsp;wf&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MATCH</span>; <span class="id">ss</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;call&nbsp;fsim&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">make_match_genvs</span>; <span class="tactic">eauto</span>. { <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. } <span class="tactic">intro</span> <span class="id">SIMGE</span>. <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">CALLSRC</span>. <span class="id">inv</span> <span class="id">MATCH</span>; <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MATCHST</span>; <span class="id">ss</span>. <span class="tactic">destruct</span> <span class="id">st_tgt0</span>; <span class="id">ss</span>. <span class="id">clarify</span>. <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>. <span class="id">exploit</span> <span class="id">SOUND</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">Q</span>; <span class="id">des</span>. <span class="id">exploit</span> <span class="id">wt_callstate_agree</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">AGCS</span> <span class="id">AGARGS</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">MCOMPAT0</span>: <span class="id">sm0</span>.(<span class="id">SimMemInj.inj</span>) = <span class="id">j</span>). { <span class="id">inv</span> <span class="id">MCOMPAT</span>. <span class="id">ss</span>. } <span class="id">clarify</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexpl</span> <span class="id">match_stacks_sp_ofs</span> <span class="id">RSP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">arguments_perm</span>; <span class="tactic">eauto</span>. { <span class="tactic">eapply</span> <span class="id">sep_drop_tail3</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">eauto</span>. } <span class="id">i</span>; <span class="id">des</span>. <span class="id">psimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">arguments_private</span>; <span class="tactic">eauto</span>. { <span class="tactic">eapply</span> <span class="id">sep_drop_tail3</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">eauto</span>. } <span class="id">i</span>; <span class="id">des</span>. <span class="id">psimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">Mem.range_perm_free</span>. { <span class="id">ii</span>. <span class="id">spc</span> <span class="id">H</span>. <span class="id">zsimpl</span>. <span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>. } <span class="tactic">intros</span> [<span class="id">m_tgt0</span> <span class="id">FREETGT</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_external_arguments</span>; <span class="tactic">eauto</span>. { <span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">eauto</span>. } <span class="tactic">intro</span> <span class="id">ARGS</span>; <span class="id">des</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">VALID</span>: <span class="id">Mem.valid_block</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm0</span>) <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exploit</span> <span class="id">match_stacks_sp_valid</span>; <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="tactic">eauto</span>. }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MCOMPAT</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">SimMemInj.free_right</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">u</span>. <span class="id">ii</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>. <span class="tactic">do</span> 2 <span class="id">spc</span> <span class="id">H0</span>. <span class="id">zsimpl</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exploit</span> <span class="id">match_stacks_sp_valid</span>; <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des</span>. <span class="id">clarify</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexpl</span> <span class="id">Mem.nextblock_free</span> <span class="id">NB</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">EXTTGT</span>: <span class="id">exists</span> <span class="id">skd_tgt</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">skenv_link</span> <span class="id">tfptr</span> = <span class="id">Some</span> <span class="id">skd_tgt</span> /\ <span class="id">Sk.get_csig</span> <span class="id">skd_tgt</span> = <span class="id">Some</span> <span class="id">sg</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">folder</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;copied&nbsp;from&nbsp;InliningproofC&nbsp;*)</span><br/>
<div class="doc">TODO: remove redundancy *</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">SIMSKENV</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">fptr_arg</span> = <span class="id">tfptr</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">FPTR</span>; <span class="id">ss</span>. <span class="id">des_ifs_safe</span>. <span class="tactic">apply</span> <span class="id">Genv.find_funct_ptr_iff</span> <span class="kwd">in</span> <span class="id">SIG</span>. <span class="tactic">unfold</span> <span class="id">Genv.find_def</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">SIMSKE</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">INJECT</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">DOMAIN</span> <span class="id">b1</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Genv.genv_defs_range</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">folder</span>. <span class="tactic">eapply</span> (<span class="id">fsim_external_funct_inject</span> <span class="id">SIMGE</span>); <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">ge</span>. <span class="tactic">eapply</span> <span class="id">SimMemInjC.skenv_inject_revive</span>; <span class="id">et</span>. <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">psimpl</span>. <span class="id">zsimpl</span>. <span class="id">des</span>. <span class="id">inv</span> <span class="id">WF</span>. <span class="tactic">unfold</span> <span class="id">Genv.find_funct</span> <span class="kwd">in</span> <span class="id">EXTTGT</span>. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_funct_ptr_iff</span> <span class="kwd">in</span> <span class="id">EXTTGT</span>. <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">WFPARAM</span> <span class="kwd">in</span> <span class="id">EXTTGT</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Sk.get_csig</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">ii</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_zero</span>. <span class="tactic">eapply</span> <span class="id">Z.divide_0_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="id">ss</span>; <span class="id">et</span>. <span class="id">econs</span>; <span class="id">ss</span>; <span class="id">et</span>. <span class="id">u</span>. <span class="id">i</span>. <span class="id">des</span>. <span class="id">clarify</span>. <span class="tactic">eapply</span> <span class="id">Mem.free_range_perm</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">rp</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">u</span>. <span class="id">ii</span>. <span class="id">des</span>; <span class="id">clarify</span>. <span class="id">specialize</span> (<span class="id">H0</span> <span class="id">x1</span>). <span class="id">zsimpl</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">rp</span>; [<span class="tactic">eapply</span> <span class="id">H0</span>; <span class="tactic">eauto</span>|..]; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc</span>. <span class="tactic">rewrite</span> <span class="id">sep_comm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">globalenv_inject_incr</span> <span class="kwd">with</span> (<span class="id">j</span>:= <span class="id">sm0</span>.(<span class="id">SimMemInj.inj</span>)); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">MINJ</span>. <span class="tactic">eapply</span> <span class="id">inject_incr_refl</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">SimMemInj.inject_separated_frozen</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">MINJ</span>. <span class="tactic">eapply</span> <span class="id">SimMemInj.frozen_refl</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">rewrite</span> <span class="id">sep_comm</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="id">bar</span>. <span class="tactic">move</span> <span class="id">SEP</span> <span class="tactic">at</span> <span class="id">bottom</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SEP</span> <span class="kwd">as</span> (<span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>). <span class="id">sep_split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">m_invar</span>; <span class="tactic">eauto</span>. <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">Mem_unchanged_on_bot</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">NB</span>. <span class="id">refl</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">B</span> <span class="kwd">as</span> (<span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span>). <span class="id">sep_split</span>; <span class="id">revgoals</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">MWF1</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">MSRC</span>. <span class="tactic">rewrite</span> <span class="id">MINJ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">LE</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stack_contents_at_external</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm0</span>) <span class="id">stack</span> <span class="id">cs</span>' <span class="id">sg</span>).(<span class="id">m_footprint</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;2=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">stack_contents</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm0</span>) <span class="id">stack</span> <span class="id">cs</span>').(<span class="id">m_footprint</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">erewrite</span> <span class="id">stack_contents_at_external_m_footprint</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">clear</span> - <span class="id">STACKS</span> <span class="id">F</span>. <span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">F</span>; <span class="id">et</span>. <span class="id">erewrite</span> &lt;- <span class="id">stack_contents_at_external_m_footprint</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">MINJ</span>. <span class="tactic">eapply</span> <span class="id">stack_contents_at_external_intro</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;after&nbsp;fsim&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>. <span class="id">inv</span> <span class="id">AFTERSRC</span>. <span class="id">inv</span> <span class="id">MATCH</span>; <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MATCHST</span>; <span class="id">ss</span>. <span class="tactic">destruct</span> <span class="id">st_tgt0</span>; <span class="id">ss</span>. <span class="id">clarify</span>. <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">MCOMPAT0</span>: <span class="id">sm0</span>.(<span class="id">SimMemInj.inj</span>) = <span class="id">j</span>). { <span class="id">inv</span> <span class="id">MCOMPAT</span>; <span class="id">ss</span>. } <span class="id">clarify</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexpl</span> <span class="id">match_stacks_sp_ofs</span> <span class="id">RSP</span>. <span class="id">inv</span> <span class="id">SIMRET</span>; <span class="id">ss</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">VALID</span>: <span class="id">Mem.valid_block</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm0</span>) <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">HISTORY</span>. <span class="id">inv</span> <span class="id">MATCHARG</span>. <span class="id">ss</span>. <span class="id">clarify</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">exists</span> <span class="id">m_tgt0</span>, &lt;&lt;<span class="id">UNFR</span>: <span class="id">Mem_unfree</span> <span class="id">sm_ret</span>.(<span class="id">SimMemInj.tgt</span>) <span class="id">sp</span> 0 (4 * <span class="id">size_arguments</span> <span class="id">sg_arg</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id">Some</span> <span class="id">m_tgt0</span>&gt;&gt;).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Mem_unfree_suceeds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="tactic">eapply</span> <span class="id">Plt_Ple_trans</span>; <span class="tactic">eauto</span>. <span class="id">etransitivity</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">MLE</span>. <span class="tactic">eapply</span> <span class="id">MLEAFTR</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <span class="id">des</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (@<span class="id">SimMemInjC.unfree_right</span> (<span class="id">SimMemInj.unlift</span>' <span class="id">sm_arg</span> <span class="id">sm_ret</span>)); <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">UNFR</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">HISTORY</span>. <span class="id">inv</span> <span class="id">CALLSRC</span>. <span class="id">inv</span> <span class="id">CALLTGT</span>. <span class="tactic">rewrite</span> <span class="id">RSP</span> <span class="kwd">in</span> *. <span class="id">clarify</span>. <span class="id">psimpl</span>. <span class="id">zsimpl</span>. <span class="id">inv</span> <span class="id">SIMARGS</span>; <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">sg</span> = <span class="id">sg_arg</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">des</span>. <span class="id">clarify</span>. <span class="id">inv</span> <span class="id">SIMSKENV</span>. <span class="id">inv</span> <span class="id">SIMSKELINK</span>. <span class="id">ss</span>. <span class="id">r</span> <span class="kwd">in</span> <span class="id">SIMSKENV</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">fsim_external_inject_eq</span>; <span class="id">et</span>. <span class="id">i</span>. <span class="tactic">subst</span> <span class="id">tfptr</span>. <span class="id">clarify</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">CTGT</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">NP</span>: <span class="id">Mem_range_noperm</span> (<span class="id">SimMemInj.tgt</span> <span class="id">sm_arg</span>) <span class="id">blk</span> 0 (4 * <span class="id">size_arguments</span> <span class="id">sg_arg</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">Mem_free_noperm</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem_unchanged_noperm</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">NP</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_implies</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE0</span>. <span class="id">ii</span>. <span class="id">ss</span>. <span class="id">u</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">arguments_private</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">sep_drop_tail3</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des</span>. <span class="id">psimpl</span>. <span class="id">spc</span> <span class="id">H1</span>. <span class="id">zsimpl</span>. <span class="id">inv</span> <span class="id">MATCHARG</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">INJ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">u</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">des</span>; <span class="id">clarify</span>. <span class="tactic">eapply</span> <span class="id">H1</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">MCOMPAT</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_block_free_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="id">bar</span>. <span class="id">inv</span> <span class="id">MLE</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">TGTPARENTEQ</span>. <span class="id">clear_until_bar</span>. <span class="id">r</span>. <span class="tactic">unfold</span> <span class="id">brange</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> <span class="id">match_stacks_sp_valid</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">SPVALID</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">des_safe</span>. <span class="id">clarify</span>. <span class="tactic">eapply</span> <span class="id">SPVALID1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <span class="id">i</span>; <span class="id">des</span>. <span class="id">ss</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">EXTTGT</span>: <span class="id">exists</span> <span class="id">skd</span>, <span class="id">Genv.find_funct</span> <span class="id">skenv_link</span> <span class="id">tfptr</span> = <span class="id">Some</span> <span class="id">skd</span> /\ <span class="id">Sk.get_csig</span> <span class="id">skd</span> = <span class="id">Some</span> <span class="id">sg_arg</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">HISTORY</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">MATCHARG</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">SIMSKENV</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">SIMSKELINK</span>. <span class="id">rr</span> <span class="kwd">in</span> <span class="id">SIMSKENV</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">esplits</span>; <span class="id">et</span>. <span class="id">rpapply</span> <span class="id">SIG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">f_equal</span>. <span class="id">clarify</span>. <span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">fsim_external_inject_eq</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">clarify</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">sm1</span>; <span class="id">esplits</span>; <span class="tactic">eauto</span>; [|<span class="id">i</span>; <span class="tactic">split</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">inv</span> <span class="id">MWFAFTR</span>. <span class="id">ss</span>. <span class="id">etrans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MLE</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">TGTPARENTEQNB</span>. <span class="id">inv</span> <span class="id">SIMSKENV</span>. <span class="id">inv</span> <span class="id">SIMSKELINK</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> <span class="id">NBTGT</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">clear</span> - <span class="id">MLE2</span> <span class="id">GOOD</span> <span class="id">DUMMY</span> <span class="id">STACKS</span>. <span class="tactic">destruct</span> <span class="id">stack</span>; <span class="id">ss</span>; <span class="id">des_ifs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">esplits</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>; <span class="id">ss</span>. <span class="id">ii</span>. <span class="id">exploit</span> <span class="id">GOOD</span>; <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">val_inject_incr</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE2</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">DUMMY</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="id">exploit</span> <span class="id">GOOD</span>; <span class="id">et</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">val_inject_incr</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE2</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">WTST</span>: <span class="id">wt_state</span> (<span class="id">Linear.Returnstate</span> <span class="id">stack</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Locmap.setpair</span> (<span class="id">loc_result</span> <span class="id">sg_arg</span>) (<span class="id">typify</span> <span class="id">v_src</span> (<span class="id">proj_sig_res</span> <span class="id">sg_arg</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LTL.undef_caller_save_regs</span> <span class="id">ls_arg</span>)) (<span class="id">SimMemInj.src</span> <span class="id">sm_ret</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">clear</span> - <span class="id">SOUND</span>. <span class="id">exploit</span> <span class="id">SOUND</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">Q</span>; <span class="id">des</span>. <span class="id">inv</span> <span class="id">Q</span>.<br/>
<br/>
<div class="doc">directly copied from LineartypingC.v *</div>
<div class="doc">TODO: provide it in metatheory *</div>
<div class="doc">I tried it (just add "(SOUND: sound_state su0 m_init st_src1)" in MatchSimModSem.v - AFTERFSIM,
          but it has some difficulty.. *</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> (<span class="id">loc_result_caller_save</span> <span class="id">sg_arg</span>); <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">RES</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> (<span class="id">loc_result_one</span> <span class="id">sg_arg</span>); <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">ONE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">des</span>. <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">Locmap.setpair</span>. <span class="id">des_ifs</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">wt_setreg</span>; <span class="id">ss</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">wt_undef_caller_save_regs</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">mreg_type_any</span>. <span class="tactic">apply</span> <span class="id">has_type_any</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="tactic">destruct</span> <span class="id">l</span>; <span class="id">ss</span>; <span class="tactic">rewrite</span> <span class="id">locmap_get_set_loc_result</span>; <span class="id">ss</span>; <span class="id">des_ifs</span>; <span class="tactic">rewrite</span> <span class="id">AGCS</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">ii</span>. <span class="tactic">rewrite</span> <span class="id">locmap_get_set_loc_result</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">WTST</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">STACKS0</span>: <span class="id">match_stacks</span> <span class="id">tge</span> <span class="id">_</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_ret</span>) (<span class="id">stackframes_after_external</span> <span class="id">stack</span>) <span class="id">cs</span>' <span class="id">sg_arg</span> <span class="id">sm1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">match_stacks_change_meminj</span> <span class="kwd">with</span> (<span class="id">j</span>:= (<span class="id">SimMemInj.inj</span> <span class="id">sm0</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">inject_incr_trans</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE0</span>. <span class="tactic">eapply</span> <span class="id">inject_incr_trans</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE</span>. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">MINJ</span>. <span class="tactic">clear</span> - <span class="id">SIMSKENV</span> <span class="id">MLE2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="id">inv</span> <span class="id">SIMSKENV</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">MLE2</span>. <span class="tactic">clear</span> <span class="id">MAXSRC</span> <span class="id">MAXTGT</span>. <span class="tactic">destruct</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm0</span> <span class="id">b1</span>) <span class="id">eqn</span>:<span class="id">T</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">p</span>. <span class="id">exploit</span> <span class="id">INCR</span>; <span class="id">et</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">FROZEN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">NEW_IMPLIES_OUTSIDE</span>; <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">inv</span> <span class="id">SIMSKELINK</span>. <span class="id">inv</span> <span class="id">INJECT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">DOMAIN</span>; <span class="id">et</span>. <span class="id">i</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">MINJ</span>. <span class="tactic">clear</span> - <span class="id">SIMSKENV</span> <span class="id">MLE2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="id">inv</span> <span class="id">SIMSKENV</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">MLE2</span>. <span class="tactic">clear</span> <span class="id">MAXSRC</span> <span class="id">MAXTGT</span>. <span class="tactic">destruct</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm0</span> <span class="id">b1</span>) <span class="id">eqn</span>:<span class="id">T</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">p</span>. <span class="id">exploit</span> <span class="id">INCR</span>; <span class="id">et</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">FROZENLO</span>. <span class="id">exploit</span> <span class="id">NEW_IMPLIES_OUTSIDE</span>; <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">inv</span> <span class="id">SIMSKELINK</span>. <span class="id">inv</span> <span class="id">INJECT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">SIMSKENV</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">NBTGT</span> <span class="kwd">in</span> *. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_le</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">STACKS</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">intros</span> ? ? ? <span class="id">VALID0</span> <span class="id">MAP0</span>. <span class="tactic">rewrite</span> <span class="id">MINJ</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">bar</span>. <span class="id">inv</span> <span class="id">MLE0</span>. <span class="id">ss</span>. <span class="id">bar</span>. <span class="id">inv</span> <span class="id">HISTORY</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="id">inv</span> <span class="id">MATCHARG</span>. <span class="id">ss</span>. <span class="id">clarify</span>. <span class="tactic">rewrite</span> <span class="id">INJ</span> <span class="kwd">in</span> *. <span class="id">clear_until_bar</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_arg</span> <span class="id">b</span>) <span class="id">eqn</span>:<span class="id">MAP1</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">p</span>; <span class="id">ss</span>. <span class="tactic">apply</span> <span class="id">INCR</span> <span class="kwd">in</span> <span class="id">MAP1</span>. <span class="id">clarify</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">exfalso</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">FROZEN</span>. <span class="id">exploit</span> <span class="id">NEW_IMPLIES_OUTSIDE</span>; <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">VALID0</span> <span class="id">OUTSIDE_TGT</span> <span class="id">MLE</span>. <span class="id">inv</span> <span class="id">MLE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="id">inv</span> <span class="id">TGTUNCHANGED</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">intros</span> <span class="id">b_src</span> <span class="id">b_tgt</span> <span class="id">delta</span> <span class="id">ofs</span> <span class="id">VALID0</span> <span class="id">MAP0</span> <span class="id">PERM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">VALID1</span>: <span class="id">Mem.valid_block</span> (<span class="id">SimMemInj.src</span> <span class="id">sm0</span>) <span class="id">b_src</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">MCOMPAT</span>. <span class="tactic">rewrite</span> <span class="id">MSRC</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> <span class="id">MINJ</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">HISTORY</span>. <span class="id">inv</span> <span class="id">MATCHARG</span>; <span class="id">ss</span>. <span class="id">clarify</span>. <span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> <span class="id">INJ</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> - <span class="id">MLE0</span> <span class="id">VALID0</span> <span class="id">MAP0</span> <span class="id">PERM</span> <span class="id">MWF0</span> <span class="id">MWF3</span> <span class="id">NB</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NNPP</span>. <span class="tactic">intro</span> <span class="id">OUTSRC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_arg</span> <span class="id">b_src</span>) <span class="id">eqn</span>:<span class="id">T</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">p</span>; <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.mi_freeblocks</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">MWF3</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MLE0</span>. <span class="id">inv</span> <span class="id">FROZEN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">NEW_IMPLIES_OUTSIDE</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> <span class="id">NB</span> <span class="kwd">in</span> *. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MLE2</span>. <span class="tactic">eapply</span> <span class="id">MAXSRC</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">bar</span>. <span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">econs</span>; <span class="id">et</span>. <span class="id">inv</span> <span class="id">AGL</span>. <span class="id">econs</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_return</span> <span class="kwd">with</span> (<span class="id">j</span>:= <span class="id">sm_ret</span>.(<span class="id">SimMemInj.inj</span>)); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">agree_regs_set_pair</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">typify</span>. <span class="id">des_ifs</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;TODO:&nbsp;Remove&nbsp;Mach.regset_after_external&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> <span class="id">regset_after_external</span> <span class="kwd">with</span> <span class="id">undef_caller_save_regs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_regs_undef_caller_save_regs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_regs_inject_incr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">inject_incr_trans</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE0</span>. <span class="id">ss</span>. <span class="tactic">apply</span> <span class="id">MLE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">hexploit</span> (<span class="id">parent_locset_after_external</span> <span class="id">stack</span>); <span class="id">et</span>. <span class="id">i</span>; <span class="id">des</span>; <span class="id">clarify</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">AFTER</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_callee_save_regs_undef_outgoing_slots</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_callee_save_regs_set_result</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_callee_save_regs_after</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">bar</span>. <span class="tactic">move</span> <span class="id">HISTORY</span> <span class="tactic">at</span> <span class="id">bottom</span>. <span class="id">inv</span> <span class="id">HISTORY</span>. <span class="id">inv</span> <span class="id">MATCHARG</span>. <span class="id">ss</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rename</span> <span class="id">sm0</span> <span class="id">into</span> <span class="id">sm_at</span>. <span class="tactic">rename</span> <span class="id">sm1</span> <span class="id">into</span> <span class="id">sm_after</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">RSP0</span> <span class="kwd">in</span> *. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexpl</span> <span class="id">Mem_nextblock_unfree</span> <span class="id">NB</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc</span>. <span class="tactic">rewrite</span> <span class="id">sep_comm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP0</span>. <span class="tactic">rewrite</span> <span class="id">sep_comm</span> <span class="kwd">in</span> <span class="id">SEP0</span>. <span class="tactic">destruct</span> <span class="id">SEP0</span> <span class="kwd">as</span> (<span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sep_split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">globalenv_inject_incr_strong</span> <span class="kwd">with</span> (<span class="id">j</span>:= <span class="id">sm_arg</span>.(<span class="id">SimMemInj.inj</span>)); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">inv</span> <span class="id">MLE0</span>. <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">eapply</span> <span class="id">SimMemInj.inject_separated_frozen</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MLE0</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">MWF2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SimMemInj.frozen_shortened</span>; <span class="tactic">eauto</span>; <span class="id">refl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">rewrite</span> &lt;- <span class="id">NB0</span>. <span class="id">inv</span> <span class="id">MLE0</span>; <span class="id">ss</span>. <span class="tactic">clear</span> - <span class="id">TGTUNCHANGED</span>. <span class="id">change</span> <span class="id">Pos.le</span> <span class="kwd">with</span> <span class="id">Ple</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_comm</span>. <span class="tactic">rewrite</span> <span class="id">sep_comm</span> <span class="kwd">in</span> <span class="id">B</span>. <span class="tactic">destruct</span> <span class="id">B</span> <span class="kwd">as</span> (<span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sep_split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ss</span>. <span class="id">rp</span>; <span class="tactic">try</span> <span class="tactic">eapply</span> <span class="id">MWF2</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">hexploit</span> <span class="id">SimMemInjC.minjection_disjoint_footprint_private</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">PRIV0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SimMemInjC.minjection_private_disjoint_footprint</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">SimMemInj.tgt_private</span> <span class="id">sm_arg</span> &lt;2= <span class="id">SimMemInj.tgt_external</span> <span class="id">sm_ret</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">clear</span> - <span class="id">MLE0</span>. <span class="id">inv</span> <span class="id">MLE0</span>. <span class="id">ss</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">TGTPARENTEQ</span>. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MWF</span>. <span class="tactic">do</span> 3 (<span class="id">etrans</span>; <span class="tactic">try</span> <span class="id">eassumption</span>; <span class="tactic">eauto</span>). <span class="id">etrans</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">erewrite</span> <span class="id">stack_contents_at_external_m_footprint</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">stackframes_after_external_footprint</span>. <span class="tactic">eapply</span> <span class="id">stack_contents_footprint_irr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">STEP0</span>: <span class="id">SimMemInj.tgt</span> <span class="id">sm_ret</span> |= <span class="id">stack_contents_at_external</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_arg</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cs</span> <span class="id">cs</span>'0 <span class="id">sig</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">m_invar</span>; <span class="tactic">eauto</span>. <span class="id">inv</span> <span class="id">MLE0</span>. <span class="id">ss</span>. <span class="tactic">eapply</span> <span class="id">Mem.unchanged_on_implies</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="tactic">eapply</span> <span class="id">SimMemInjC.minjection_disjoint_footprint_private</span>; <span class="tactic">eauto</span>. }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">STEP1</span>: <span class="id">SimMemInj.tgt</span> <span class="id">sm_ret</span> |= <span class="id">stack_contents_at_external</span> (<span class="id">SimMemInj.inj</span> <span class="id">sm_ret</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cs</span> <span class="id">cs</span>'0 <span class="id">sig</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">MLE0</span>. <span class="tactic">eapply</span> <span class="id">stack_contents_at_external_change_meminj</span>; <span class="tactic">eauto</span>. }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">stack_contents_at_external_spec_elim</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;final&nbsp;fsim&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">FINALSRC</span>. <span class="id">inv</span> <span class="id">MATCH</span>. <span class="id">inv</span> <span class="id">MATCHST</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_stacks_sp_ofs</span>; <span class="tactic">eauto</span>; <span class="tactic">intro</span> <span class="id">RSP</span>; <span class="id">des_safe</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;ss;&nbsp;clarify.&nbsp;des_ifs;&nbsp;sep_simpl_tac;&nbsp;des;&nbsp;ss.&nbsp;Undo&nbsp;1.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;des_ifs;&nbsp;sep_simpl_tac;&nbsp;des_safe;&nbsp;ss.&nbsp;Undo&nbsp;1.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(***&nbsp;TODO:&nbsp;Fix&nbsp;des_safe&nbsp;with&nbsp;check_safe!!&nbsp;***)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>; <span class="id">clarify</span>. <span class="id">des</span>. <span class="id">des_ifs</span>; <span class="id">sep_simpl_tac</span>; <span class="id">des</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;unsguard&nbsp;AGLOCS.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">st_tgt0</span>; <span class="id">ss</span>. <span class="id">clarify</span>. <span class="id">ss</span>. <span class="id">clarify</span>. <span class="id">ss</span>. <span class="id">inv</span> <span class="id">STACKS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> (<span class="id">loc_result_one</span> <span class="id">init_sg</span>); <span class="tactic">eauto</span>. <span class="id">i</span>; <span class="id">des_safe</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">stack_contents_args</span> <span class="id">dummy_frame_contents</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ss</span>. <span class="tactic">unfold</span> <span class="id">dummy_frame_contents</span> <span class="kwd">in</span> *. <span class="id">psimpl</span>. <span class="id">clarify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">hexploit</span> (<span class="id">Mem.range_perm_free</span> <span class="id">sm0</span>.(<span class="id">SimMemInj.tgt</span>) <span class="id">sp</span> 0 (4 * (<span class="id">size_arguments</span> <span class="id">init_sg</span>))); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">MCOMPAT</span>. <span class="tactic">clear</span> - <span class="id">SEP</span>. <span class="tactic">apply</span> <span class="id">sep_pick1</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="id">rr</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="id">des</span>. <span class="id">zsimpl</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">xomega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">sm_tgt1</span> &amp; <span class="id">FREETGT</span>).<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">j</span> = <span class="id">sm0</span>.(<span class="id">SimMemInj.inj</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">MCOMPAT</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">clarify</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">SimMemInj.free_right</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">MCOMPAT</span>. <span class="tactic">clear</span> - <span class="id">SEP</span> <span class="id">SPVALID</span>. <span class="tactic">apply</span> <span class="id">sep_drop_tail3</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SEP</span> <span class="kwd">as</span> (<span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">DISJ</span>). <span class="id">ss</span>. <span class="id">des</span>. <span class="id">zsimpl</span>. <span class="id">clear_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ii</span>. <span class="id">rr</span> <span class="kwd">in</span> <span class="id">DISJ</span>. <span class="id">rr</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">DISJ</span> <span class="id">sp</span> <span class="id">ofs</span>). <span class="id">ss</span>. <span class="id">ii</span>. <span class="id">exploit</span> <span class="id">DISJ</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des_safe</span>. <span class="tactic">rename</span> <span class="id">sm1</span> <span class="id">into</span> <span class="id">sm_ret</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eexists</span> <span class="id">sm_ret</span>, (<span class="id">Retv.mk</span> <span class="id">_</span> <span class="id">_</span>). <span class="id">esplits</span>; <span class="tactic">eauto</span>; <span class="id">cycle</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">MCOMPAT</span>. <span class="id">econs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ONE</span>. <span class="id">ss</span>. <span class="id">specialize</span> (<span class="id">AGREGS</span> <span class="id">mr_res</span>). <span class="tactic">eapply</span> <span class="id">val_inject_incr</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">MCOMPAT</span>. <span class="id">econs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">ii</span>. <span class="id">specialize</span> (<span class="id">AGCSREGS</span> <span class="id">mr</span>). <span class="id">ss</span>. <span class="id">specialize</span> (<span class="id">GOOD</span> <span class="id">mr</span> <span class="id">H</span>). <span class="id">des_safe</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">AGCSREGS</span> <span class="kwd">in</span> *; <span class="id">ss</span>. <span class="tactic">destruct</span> (<span class="id">Val.eq</span> (<span class="id">ls0</span> (<span class="id">R</span> <span class="id">mr</span>)) <span class="id">Vundef</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">GOOD</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">AGREGS</span> <span class="id">mr</span>). <span class="tactic">clear</span> - <span class="id">GOOD0</span> <span class="id">AGREGS</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">GOOD0</span>; <span class="id">inv</span> <span class="id">AGREGS</span>; <span class="tactic">try</span> <span class="tactic">rewrite</span> &lt;- <span class="id">H</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span> <span class="kwd">in</span> *; <span class="id">ss</span>; <span class="id">clarify</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;step&nbsp;lemma&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left</span>; <span class="id">i</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">LinearC.modsem_receptive</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MATCH</span>. <span class="id">ii</span>. <span class="id">hexploit</span> (@<span class="id">transf_step_correct</span> <span class="id">prog</span> <span class="id">rao</span> <span class="id">skenv_link</span> <span class="id">skenv_link</span> <span class="id">ge</span> <span class="id">tge</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">make_match_genvs</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">SIMSKENV</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">STEPSRC</span>. <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">hexploit1</span> <span class="id">SOUND</span>; <span class="id">ss</span>. <span class="id">des</span>. <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des</span>. <span class="tactic">destruct</span> <span class="id">st_tgt0</span>. <span class="id">ss</span>. <span class="id">folder</span>. <span class="id">r</span> <span class="kwd">in</span> <span class="id">STEPSRC</span>; <span class="id">des</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">lift_plus</span> (<span class="id">Mach.step</span> <span class="id">rao</span>) (<span class="kwd">fun</span> <span class="id">st</span> =&gt; <span class="id">get_stack</span> <span class="id">st</span> &lt;&gt; []) <span class="id">strong_wf_tgt</span>); <span class="id">ss</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">intros</span> ? <span class="id">X</span> <span class="id">Y</span>. <span class="id">rr</span> <span class="kwd">in</span> <span class="id">X</span>. <span class="id">des</span>. <span class="tactic">rewrite</span> <span class="id">Y</span> <span class="kwd">in</span> *. <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">i</span>. <span class="id">folder</span>. <span class="tactic">unfold</span> <span class="id">strong_wf_tgt</span> <span class="kwd">in</span> *. <span class="id">des</span>. <span class="id">inv</span> <span class="id">HSTEP</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">des_ifs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">des_ifs</span>; <span class="id">ss</span>; <span class="tactic">eauto</span>. <span class="id">right</span>. <span class="id">ii</span>. <span class="id">inv</span> <span class="id">HSTEP0</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="tactic">unfold</span> <span class="id">strong_wf_tgt</span> <span class="kwd">in</span> *; <span class="id">des</span>. <span class="id">inv</span> <span class="id">HSTEP</span>; <span class="tactic">try</span> <span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">ss</span>; <span class="id">clarify</span>; <span class="id">et</span>; <span class="id">des_ifs</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">intro</span> <span class="id">T</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">ss</span>; <span class="id">clarify</span>; <span class="tactic">try</span> <span class="id">inv</span> <span class="id">STACKS</span>; <span class="id">ss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>; <span class="id">des</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">left</span>. <span class="tactic">eapply</span> <span class="id">spread_dplus</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">modsem_determinate</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">s</span>. <span class="id">folder</span>. <span class="tactic">eapply</span> <span class="id">MachC.lift_plus</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">econs</span>; <span class="id">ss</span>; <span class="id">et</span>; <span class="tactic">try</span> (<span class="tactic">by</span> <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">MCOMPAT</span>; <span class="id">ss</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">esplits</span>; <span class="id">et</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">LinearC.step_preserves_last_option</span>; <span class="id">et</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">ii</span>. <span class="id">exploit</span> <span class="id">GOOD</span>; <span class="id">et</span>. <span class="id">i</span>; <span class="id">des</span>. <span class="id">esplits</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">val_inject_incr</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">MLE</span>; <span class="id">et</span>. }<br/>
<br/>
<span class="id">Unshelve</span>.<br/>
&nbsp;&nbsp;<span class="id">all</span>: <span class="id">ss</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SIMMODSEM</span>.<br/>
<br/>
<br/>
<span class="kwd">Section</span> <span class="id">SIMMOD</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">Linear.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">Mach.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">rao</span>: <span class="id">function</span> -&gt; <span class="id">code</span> -&gt; <span class="id">ptrofs</span> -&gt; <span class="kwd">Prop</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">return_address_offset_exists</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">sg</span> <span class="id">ros</span> <span class="id">c</span> <span class="id">id</span> (<span class="id">FUNCT</span>: <span class="id">In</span> (<span class="id">id</span>, <span class="id">Gfun</span> (<span class="id">Internal</span> <span class="id">f</span>)) (<span class="id">prog_defs</span> <span class="id">tprog</span>)),<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> (<span class="id">Mcall</span> <span class="id">sg</span> <span class="id">ros</span> :: <span class="id">c</span>) (<span class="id">fn_code</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ofs</span>, <span class="id">rao</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ofs</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">return_address_offset_deterministic</span>: <span class="kwd">forall</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ofs</span> <span class="id">ofs</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rao</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ofs</span> -&gt; <span class="id">rao</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ofs</span>' -&gt; <span class="id">ofs</span> = <span class="id">ofs</span>'.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">mp</span>: <span class="id">ModPair.t</span> := <span class="id">SimSymbId.mk_mp</span> (<span class="id">LinearC.module</span> <span class="id">prog</span>) (<span class="id">MachC.module</span> <span class="id">tprog</span> <span class="id">rao</span>).<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">sim_mod</span>: <span class="id">ModPair.sim</span> <span class="id">mp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7444')">Proof.</div>
<div class="proofscript" id="proof7444">
&nbsp;&nbsp;<span class="id">econs</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;- <span class="id">r</span>. <span class="tactic">eapply</span> <span class="id">Sk.match_program_eq</span>; <span class="tactic">eauto</span>. <span class="id">ii</span>. <span class="tactic">destruct</span> <span class="id">f1</span>; <span class="id">ss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">clarify</span>. <span class="id">right</span>. <span class="tactic">unfold</span> <span class="id">bind</span> <span class="kwd">in</span> <span class="id">MATCH</span>. <span class="id">des_ifs</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>. <span class="id">erewrite</span> <span class="id">transf_function_sig</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">clarify</span>. <span class="id">left</span>. <span class="id">esplits</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">ii</span>. <span class="id">inv</span> <span class="id">SIMSKENVLINK</span>. <span class="id">inv</span> <span class="id">SIMSKENV</span>. <span class="tactic">eapply</span> <span class="id">sim_modsem</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span>. <span class="id">ss</span>. <span class="id">uge0</span>. <span class="id">des_ifs</span>. <span class="tactic">unfold</span> <span class="id">SkEnv.revive</span> <span class="kwd">in</span> *. <span class="tactic">apply</span> <span class="id">Genv_map_defs_def</span> <span class="kwd">in</span> <span class="id">Heq</span>. <span class="id">des</span>. <span class="id">ss</span>. <span class="id">gesimpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Genv_map_defs_def</span> <span class="kwd">in</span> <span class="id">FIND</span>. <span class="id">des</span>. <span class="tactic">unfold</span> <span class="id">o_bind</span>, <span class="id">o_join</span>, <span class="id">o_map</span> <span class="kwd">in</span> *. <span class="id">des_ifs</span>. <span class="id">ss</span>. <span class="id">clear_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">return_address_offset_exists</span>; <span class="id">et</span>. <span class="tactic">eapply</span> <span class="id">in_prog_defmap</span>; <span class="id">et</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SIMMOD</span>.<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</div>
</body>
</html>
